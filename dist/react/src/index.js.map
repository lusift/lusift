{"version":3,"file":"index.js","sources":["../../../node_modules/global/window.js","../../../src/common/logger.ts","../../../src/common/store/localStorage.ts","../../../src/common/utils/isOfType/index.ts","../../../src/common/utils/mergeDeep.ts","../../../src/common/utils/styleObjectToString.ts","../../../src/common/utils/getStepUID.ts","../../../src/common/utils/getElementPosition.ts","../../../src/common/utils/changeAsyncStepStatus.ts","../../../src/common/utils/doesStepMatchDisplayCriteria.ts","../../../node_modules/tabbable/dist/index.esm.js","../../../node_modules/focus-trap/dist/focus-trap.esm.js","../../../src/common/utils/addFocusTrap.ts","../../../src/common/utils/hasFocussableElements.ts","../../../src/common/utils/debounce.ts","../../../src/common/utils/copyObject.ts","../../../src/common/constants/index.ts","../../../src/common/progressBar/renderProgressBar.ts","../../../src/common/closeXButton/renderCloseXButton.ts","../../../node_modules/floating-ui-tooltip/dist/index.js","../../../src/common/createTooltip.ts","../../../src/tooltip/createTooltip.ts","../../../src/backdrop/createOverlayElement.ts","../../../src/backdrop/Backdrop.ts","../../../src/tooltip/Tooltip.ts","../../../src/modal/createModal.ts","../../../src/modal/Modal.ts","../../../src/hotspot/createHotspotTooltip.ts","../../../src/hotspot/beacon-element.ts","../../../src/hotspot/Hotspot.ts","../../../src/lusift/startStepInstance.ts","../../../src/lusift/Guide.ts","../../../src/lusift/defaults.ts","../../../src/lusift/Lusift.ts","../../../src/lusift/addDefaultCSS.ts","../../../src/lusift/index.ts","../../../src/react/src/index.tsx","../../../src/common/utils/vanillaRender.ts"],"sourcesContent":["var win;\n\nif (typeof window !== \"undefined\") {\n    win = window;\n} else if (typeof global !== \"undefined\") {\n    win = global;\n} else if (typeof self !== \"undefined\"){\n    win = self;\n} else {\n    win = {};\n}\n\nmodule.exports = win;\n","const messagePrefix = \"Lusift:\";\n\n/* export function log(message: string, ...args: any[]) {\n    console.log(`${messagePrefix} ${message}`, ...args);\n} */\nexport const log = console.log;\n\nexport function warn(message: string, ...args: any[]) {\n    console.warn(`${messagePrefix} ${message}`, ...args);\n}\n\nexport function error(message: string, ...args: any[]) {\n    console.error(`${messagePrefix} ${message}`, ...args);\n}\n","import { window, document } from \"global\";\nimport { error } from \"../logger\";\n\nif (!window) {\n    error(\"window is undefined\");\n}\n\nconst STATE_ITEM_NAME = \"lusift_state\";\n\n/**\n * This function checks if the lusift_state is saved in localStorage\n */\nexport const loadState = () => {\n    try {\n        // Load the data saved in localStorage, against the key 'lusift_state'\n        const serialisedState = window.localStorage.getItem(STATE_ITEM_NAME);\n\n        // Passing undefined to createStore will result in our app getting the default state\n        // If no data is saved, return undefined\n        if (!serialisedState) return undefined;\n\n        // De-serialise the saved state, and return it.\n        return JSON.parse(serialisedState);\n    } catch (err) {\n        // Return undefined if localStorage is not available,\n        // or data could not be de-serialised,\n        // or there was some other error\n        return undefined;\n    }\n};\n\n\n/**\n * This function accepts the app state, and saves it to localStorage\n * @param state\n */\n\nexport const saveState = state => {\n    try {\n        // Convert the state to a JSON string\n        const serialisedState = JSON.stringify(state);\n\n        // Save the serialised state to localStorage against the key 'lusift_state'\n        window.localStorage.setItem(STATE_ITEM_NAME, serialisedState);\n    } catch (err) {\n        // Log errors here, or ignore\n    }\n};\n\n\nexport const setDefaultState = (): void => {\n    saveState({});\n}\n","import { GuideType, Content } from \"../../types\";\nimport { log } from \"../../logger\";\n\nexport function isObject(item: any): boolean {\n    return item instanceof Object && item.constructor === Object;\n}\n\nexport function isObjectOrUndefined(object: any): boolean {\n    return isObject(object) || typeof object === \"undefined\";\n}\n\nfunction isOfTypeTooltipPlacement(item: any): boolean {\n    const positions = [\"bottom\", \"top\", \"right\", \"left\"];\n    positions.forEach(p => {\n        positions.push(`${p}-start`);\n        positions.push(`${p}-end`);\n    });\n    positions.push('auto');\n\n    return isObject(item) && positions.includes(item.position) &&\n        item.orientation === 'auto' || item.orientation === 'fixed';\n}\n\nexport function isOfTypeTooltipData(object: any): boolean {\n\n    return (\n        isObject(object) &&\n        typeof object.arrow === \"boolean\" &&\n        (!object.offset || (object.offset instanceof Object && object.offset.length === 2)) &&\n        (!object.actions || isObject(object.actions)) &&\n        isOfTypeTooltipPlacement(object.placement) &&\n        isOfTypeProgressConfig(object.progressBar) &&\n        (typeof object.arrowSizeScale === \"number\") &&\n        (typeof object.contentBody === \"string\" ||\n            (!object.contentBody && typeof object.contentBody !== \"boolean\")) &&\n        // (typeof object.contentBody === 'string' && !!object.contentBody) &&\n        isObjectOrUndefined(object.progressOn) &&\n        isObjectOrUndefined(object.backdrop)\n    );\n}\n\nexport function isOfTypeTarget(object: any, type: string): boolean {\n    const comparators = [\"is\", \"contains\", \"endsWith\", \"startsWith\", \"regex\"];\n    const elementSelectorExists =\n        typeof object.elementSelector === \"string\" && !!object.elementSelector;\n\n    return (\n        isObject(object) &&\n        (elementSelectorExists || type === \"modal\") && //validate element selector\n        isObject(object.path) &&\n        typeof object.path.comparator === \"string\" &&\n        comparators.includes(object.path.comparator) &&\n        typeof object.path.value === \"string\"\n    ); //validate path\n}\n\nexport function isOfTypeTooltipActions(object: any): boolean {\n    return (\n        isObject(object) &&\n        Object.entries(object).every(prop => isObject(prop)) &&\n        isObjectOrUndefined(object.closeButton.styleProps) &&\n        isObjectOrUndefined(object.navSection.styleProps) &&\n        isObjectOrUndefined(object.navSection.nextButton) &&\n        isObjectOrUndefined(object.navSection.nextButton.styleProps) &&\n        isObjectOrUndefined(object.navSection.prevButton) &&\n        isObjectOrUndefined(object.navSection.dissmissLink) &&\n        isObjectOrUndefined(object.navSection.dissmissLink.styleProps)\n    );\n}\n\nexport function isOfTypeProgressConfig(object: any): boolean {\n    return (\n        isObject(object) &&\n        isObject(object.styleProps)\n    );\n}\n\nexport function isOfTypeTooltip(object: any): boolean {\n    return (\n        isOfTypeTooltipData(object.data) &&\n        isObjectOrUndefined(object.styleProps) &&\n        object.type === \"tooltip\" &&\n        isOfTypeTooltipData(object.data)\n    );\n}\n\nexport function isOfTypeModal(object: any): boolean {\n    return (\n        object.type === \"modal\" &&\n        isObject(object.data) &&\n        isObjectOrUndefined(object.closeButton) &&\n        isOfTypeProgressConfig(object.data.progressBar)\n    );\n}\n\nexport function isOfTypeHotspot(object: any): boolean {\n    return object.type === \"hotspot\";\n}\n\nexport function isOfTypeStep(object: any): boolean {\n    const stepTypes = [\"tooltip\", \"hotspot\", \"modal\"];\n\n    return (\n        isObject(object) &&\n        typeof object.index === \"number\" &&\n        stepTypes.includes(object.type) &&\n        // target\n        isOfTypeTarget(object.target, object.type) &&\n        (isOfTypeTooltip(object) || isOfTypeHotspot(object) || isOfTypeModal(object))\n    );\n}\n\nexport function isOfTypeGuide(object: any): boolean {\n    return (\n        isObject(object) &&\n        typeof object.id === \"string\" &&\n        !!object.id &&\n        typeof object.name === \"string\" &&\n        typeof object.description === \"string\" &&\n        object.steps instanceof Object &&\n        object.steps.hasOwnProperty(\"length\") &&\n        object.steps.every(isOfTypeStep)\n    );\n}\n\nexport function isOfTypeContent(object: Content): boolean {\n    const itemTypes = [\"guide\"];\n    return (\n        isObject(object) &&\n        Object.values(object).every((item: any) => {\n            return typeof itemTypes.includes(item.type) && isOfTypeGuide(item.data);\n        })\n    );\n}\n\nexport function isOfTypeHtmlElement(element): boolean {\n    log(\"bodyContent\");\n    if (typeof element !== \"object\") return false;\n    return (\n        element.constructor.name.startsWith(\"HTML\") && element.constructor.name.endsWith(\"Element\")\n    );\n}\n\nexport const isReactComponent = (component: any): boolean => {\n    return typeof component === \"function\";\n};\n\nexport const isReactClassComponent = (component: any): boolean => {\n    // there's component.prototype.isReactComponent too\n    return isReactComponent(component) && typeof component.prototype.render === \"function\";\n};\n","import { isObject } from \"./isOfType\";\n/*\n * Deep merge properties of two objects\n * replace with lodash.merge if insufficient\n * or check this thread:\n * https://stackoverflow.com/questions/27936772/how-to-deep-merge-instead-of-shallow-merge\n */\nfunction mergeDeep(target, source) {\n  let output = Object.assign({}, target);\n  if (isObject(target) && isObject(source)) {\n    Object.keys(source).forEach(key => {\n      if (isObject(source[key])) {\n        if (!(key in target))\n        // if (typeof target.key === 'undefined')\n          Object.assign(output, { [key]: source[key] });\n        else\n          output[key] = mergeDeep(target[key], source[key]);\n      } else {\n        Object.assign(output, { [key]: source[key] });\n      }\n    });\n  }\n  return output;\n}\n\n\nexport default mergeDeep;\n","const camelCaseToHyphenCase = (camelCaseString: string) => {\n    return camelCaseString.replace(/[A-Z]/g, m => \"-\" + m.toLowerCase());\n};\n\nconst styleObjectToString = (styleProps: Object) => {\n    // convert and layout styleProps into string literal\n    let stylesString = \"\";\n    Object.keys(styleProps).forEach(key => {\n        stylesString += `${camelCaseToHyphenCase(key)}: ${styleProps[key]} !important;\\n`;\n    });\n    return stylesString;\n};\n\nexport default styleObjectToString;\n","export type UIDElementType = 'tooltip' | 'hotspot' | 'modal' | 'backdrop' | 'beacon';\n\nconst getStepUID = (\n    { guideID, index, type }: { guideID: string; index: number; type: UIDElementType }\n): string => {\n    return `lusift--g-${guideID}--${type}-${index}`;\n};\nexport default getStepUID;\n","import { window, document } from \"global\";\nimport { ElementPosition } from \"../types\";\n\nconst getElementPosition = (element: HTMLElement): ElementPosition => {\n    const { documentElement, body } = document;\n\n    const scrollTop = window.pageYOffset || documentElement.scrollTop || body.scrollTop;\n    const scrollLeft = window.pageXOffset || documentElement.scrollLeft || body.scrollLeft;\n    const elementRect = element.getBoundingClientRect();\n\n    const position: ElementPosition = {\n        top: elementRect.top + scrollTop,\n        left: elementRect.left + scrollLeft,\n        right: elementRect.left + scrollLeft + elementRect.width,\n        bottom: elementRect.top + scrollTop + elementRect.height,\n        height: elementRect.height,\n        width: elementRect.width,\n    };\n    return position;\n};\n\nexport default getElementPosition;\n","import { window } from \"global\";\nimport { loadState, saveState } from \"../store\";\n\nconst changeAsyncStepStatus = (stepIndex: number, toOpen: boolean): void => {\n    const exisitingState = loadState();\n    const { id: activeGuideID } = window.Lusift.getActiveGuide();\n    saveState({\n        ...exisitingState,\n        [activeGuideID]: {\n            ...exisitingState[activeGuideID],\n            trackingState: {\n                ...exisitingState[activeGuideID].trackingState,\n                asyncSteps: {\n                    ...exisitingState[activeGuideID].trackingState.asyncSteps,\n                    [stepIndex]: {\n                        toOpen,\n                    },\n                },\n            },\n        },\n    });\n};\n\nexport default changeAsyncStepStatus;\n","import { window, document } from \"global\";\nimport doesStringMatchRegex from \"./doesStringMatchRegex\";\n\n// e.g: currentPath = /lusift/boards | value = /*/boards\nlet doesPathMatch = (currentPath: string, value: string) => {\n    // remove `/`s from both ends of the string\n    if (currentPath[0] === '/') currentPath = currentPath.slice(1,);\n    if (currentPath[currentPath.length-1] === '/') currentPath = currentPath.slice(0, currentPath.length-1);\n\n    const currentPathElements = currentPath.split('/');\n\n    if (value[0] === '/') value = value.slice(1,);\n    if (value[value.length-1] === '/') value = value.slice(0, value.length-1);\n\n    const valuePathElements = value.split('/');\n    if (valuePathElements.length !== currentPathElements.length) return false;\n    return valuePathElements.every((value, index) => {\n        return value === currentPathElements[index] || value === '*';\n    });\n}\n\nconst doesStepPathMatch = (targetPath): boolean => {\n    // is, endsWith, startsWith, contains, regex\n    const { value, comparator } = targetPath;\n    const { pathname, hash } = window.location;\n    const currentPath = pathname + hash;\n\n    switch (comparator) {\n        case \"is\":\n            return currentPath === value;\n        case \"contains\":\n            return currentPath.includes(value);\n        case \"endsWith\":\n            return currentPath.endsWith(value);\n        case \"startWith\":\n            return currentPath.startsWith(value);\n        case \"regex\":\n            return doesPathMatch(currentPath, value);\n        default:\n            return false;\n    }\n};\n\nconst isStepElementFound = (elementSelector: string): boolean => {\n    /* log(this.guideData);\n     log('checking if element exists') */\n    return Boolean(document.querySelector(elementSelector));\n};\n\nconst doesStepMatchesDisplayCriteria = ({ target, type }): boolean => {\n    let criteriaMatch = doesStepPathMatch(target.path);\n    if (type !== \"modal\") {\n        criteriaMatch = criteriaMatch && isStepElementFound(target.elementSelector);\n    }\n    return criteriaMatch;\n};\n\nexport default doesStepMatchesDisplayCriteria;\n","/*!\n* tabbable 5.3.3\n* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE\n*/\nvar candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]:not(slot)', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable=\"false\"])', 'details>summary:first-of-type', 'details'];\nvar candidateSelector = /* #__PURE__ */candidateSelectors.join(',');\nvar NoElement = typeof Element === 'undefined';\nvar matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\nvar getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {\n  return element.getRootNode();\n} : function (element) {\n  return element.ownerDocument;\n};\n/**\n * @param {Element} el container to check in\n * @param {boolean} includeContainer add container to check\n * @param {(node: Element) => boolean} filter filter candidates\n * @returns {Element[]}\n */\n\nvar getCandidates = function getCandidates(el, includeContainer, filter) {\n  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));\n\n  if (includeContainer && matches.call(el, candidateSelector)) {\n    candidates.unshift(el);\n  }\n\n  candidates = candidates.filter(filter);\n  return candidates;\n};\n/**\n * @callback GetShadowRoot\n * @param {Element} element to check for shadow root\n * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.\n */\n\n/**\n * @callback ShadowRootFilter\n * @param {Element} shadowHostNode the element which contains shadow content\n * @returns {boolean} true if a shadow root could potentially contain valid candidates.\n */\n\n/**\n * @typedef {Object} CandidatesScope\n * @property {Element} scope contains inner candidates\n * @property {Element[]} candidates\n */\n\n/**\n * @typedef {Object} IterativeOptions\n * @property {GetShadowRoot|boolean} getShadowRoot true if shadow support is enabled; falsy if not;\n *  if a function, implies shadow support is enabled and either returns the shadow root of an element\n *  or a boolean stating if it has an undisclosed shadow root\n * @property {(node: Element) => boolean} filter filter candidates\n * @property {boolean} flatten if true then result will flatten any CandidatesScope into the returned list\n * @property {ShadowRootFilter} shadowRootFilter filter shadow roots;\n */\n\n/**\n * @param {Element[]} elements list of element containers to match candidates from\n * @param {boolean} includeContainer add container list to check\n * @param {IterativeOptions} options\n * @returns {Array.<Element|CandidatesScope>}\n */\n\n\nvar getCandidatesIteratively = function getCandidatesIteratively(elements, includeContainer, options) {\n  var candidates = [];\n  var elementsToCheck = Array.from(elements);\n\n  while (elementsToCheck.length) {\n    var element = elementsToCheck.shift();\n\n    if (element.tagName === 'SLOT') {\n      // add shadow dom slot scope (slot itself cannot be focusable)\n      var assigned = element.assignedElements();\n      var content = assigned.length ? assigned : element.children;\n      var nestedCandidates = getCandidatesIteratively(content, true, options);\n\n      if (options.flatten) {\n        candidates.push.apply(candidates, nestedCandidates);\n      } else {\n        candidates.push({\n          scope: element,\n          candidates: nestedCandidates\n        });\n      }\n    } else {\n      // check candidate element\n      var validCandidate = matches.call(element, candidateSelector);\n\n      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {\n        candidates.push(element);\n      } // iterate over shadow content if possible\n\n\n      var shadowRoot = element.shadowRoot || // check for an undisclosed shadow\n      typeof options.getShadowRoot === 'function' && options.getShadowRoot(element);\n      var validShadowRoot = !options.shadowRootFilter || options.shadowRootFilter(element);\n\n      if (shadowRoot && validShadowRoot) {\n        // add shadow dom scope IIF a shadow root node was given; otherwise, an undisclosed\n        //  shadow exists, so look at light dom children as fallback BUT create a scope for any\n        //  child candidates found because they're likely slotted elements (elements that are\n        //  children of the web component element (which has the shadow), in the light dom, but\n        //  slotted somewhere _inside_ the undisclosed shadow) -- the scope is created below,\n        //  _after_ we return from this recursive call\n        var _nestedCandidates = getCandidatesIteratively(shadowRoot === true ? element.children : shadowRoot.children, true, options);\n\n        if (options.flatten) {\n          candidates.push.apply(candidates, _nestedCandidates);\n        } else {\n          candidates.push({\n            scope: element,\n            candidates: _nestedCandidates\n          });\n        }\n      } else {\n        // there's not shadow so just dig into the element's (light dom) children\n        //  __without__ giving the element special scope treatment\n        elementsToCheck.unshift.apply(elementsToCheck, element.children);\n      }\n    }\n  }\n\n  return candidates;\n};\n\nvar getTabindex = function getTabindex(node, isScope) {\n  if (node.tabIndex < 0) {\n    // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\n    // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n    // yet they are still part of the regular tab order; in FF, they get a default\n    // `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n    // order, consider their tab index to be 0.\n    // Also browsers do not return `tabIndex` correctly for contentEditable nodes;\n    // so if they don't have a tabindex attribute specifically set, assume it's 0.\n    //\n    // isScope is positive for custom element with shadow root or slot that by default\n    // have tabIndex -1, but need to be sorted by document order in order for their\n    // content to be inserted in the correct position\n    if ((isScope || /^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || node.isContentEditable) && isNaN(parseInt(node.getAttribute('tabindex'), 10))) {\n      return 0;\n    }\n  }\n\n  return node.tabIndex;\n};\n\nvar sortOrderedTabbables = function sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n};\n\nvar isInput = function isInput(node) {\n  return node.tagName === 'INPUT';\n};\n\nvar isHiddenInput = function isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n};\n\nvar isDetailsWithSummary = function isDetailsWithSummary(node) {\n  var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {\n    return child.tagName === 'SUMMARY';\n  });\n  return r;\n};\n\nvar getCheckedRadio = function getCheckedRadio(nodes, form) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked && nodes[i].form === form) {\n      return nodes[i];\n    }\n  }\n};\n\nvar isTabbableRadio = function isTabbableRadio(node) {\n  if (!node.name) {\n    return true;\n  }\n\n  var radioScope = node.form || getRootNode(node);\n\n  var queryRadios = function queryRadios(name) {\n    return radioScope.querySelectorAll('input[type=\"radio\"][name=\"' + name + '\"]');\n  };\n\n  var radioSet;\n\n  if (typeof window !== 'undefined' && typeof window.CSS !== 'undefined' && typeof window.CSS.escape === 'function') {\n    radioSet = queryRadios(window.CSS.escape(node.name));\n  } else {\n    try {\n      radioSet = queryRadios(node.name);\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error('Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s', err.message);\n      return false;\n    }\n  }\n\n  var checked = getCheckedRadio(radioSet, node.form);\n  return !checked || checked === node;\n};\n\nvar isRadio = function isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n};\n\nvar isNonTabbableRadio = function isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n};\n\nvar isZeroArea = function isZeroArea(node) {\n  var _node$getBoundingClie = node.getBoundingClientRect(),\n      width = _node$getBoundingClie.width,\n      height = _node$getBoundingClie.height;\n\n  return width === 0 && height === 0;\n};\n\nvar isHidden = function isHidden(node, _ref) {\n  var displayCheck = _ref.displayCheck,\n      getShadowRoot = _ref.getShadowRoot;\n\n  // NOTE: visibility will be `undefined` if node is detached from the document\n  //  (see notes about this further down), which means we will consider it visible\n  //  (this is legacy behavior from a very long way back)\n  // NOTE: we check this regardless of `displayCheck=\"none\"` because this is a\n  //  _visibility_ check, not a _display_ check\n  if (getComputedStyle(node).visibility === 'hidden') {\n    return true;\n  }\n\n  var isDirectSummary = matches.call(node, 'details>summary:first-of-type');\n  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;\n\n  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {\n    return true;\n  } // The root node is the shadow root if the node is in a shadow DOM; some document otherwise\n  //  (but NOT _the_ document; see second 'If' comment below for more).\n  // If rootNode is shadow root, it'll have a host, which is the element to which the shadow\n  //  is attached, and the one we need to check if it's in the document or not (because the\n  //  shadow, and all nodes it contains, is never considered in the document since shadows\n  //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,\n  //  is hidden, or is not in the document itself but is detached, it will affect the shadow's\n  //  visibility, including all the nodes it contains). The host could be any normal node,\n  //  or a custom element (i.e. web component). Either way, that's the one that is considered\n  //  part of the document, not the shadow root, nor any of its children (i.e. the node being\n  //  tested).\n  // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the\n  //  document (per the docs) and while it's a Document-type object, that document does not\n  //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer\n  //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,\n  //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when\n  //  node is actually detached.\n\n\n  var nodeRootHost = getRootNode(node).host;\n  var nodeIsAttached = (nodeRootHost === null || nodeRootHost === void 0 ? void 0 : nodeRootHost.ownerDocument.contains(nodeRootHost)) || node.ownerDocument.contains(node);\n\n  if (!displayCheck || displayCheck === 'full') {\n    if (typeof getShadowRoot === 'function') {\n      // figure out if we should consider the node to be in an undisclosed shadow and use the\n      //  'non-zero-area' fallback\n      var originalNode = node;\n\n      while (node) {\n        var parentElement = node.parentElement;\n        var rootNode = getRootNode(node);\n\n        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow\n        ) {\n          // node has an undisclosed shadow which means we can only treat it as a black box, so we\n          //  fall back to a non-zero-area test\n          return isZeroArea(node);\n        } else if (node.assignedSlot) {\n          // iterate up slot\n          node = node.assignedSlot;\n        } else if (!parentElement && rootNode !== node.ownerDocument) {\n          // cross shadow boundary\n          node = rootNode.host;\n        } else {\n          // iterate up normal dom\n          node = parentElement;\n        }\n      }\n\n      node = originalNode;\n    } // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support\n    //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or\n    //  it might be a falsy value, which means shadow DOM support is disabled\n    // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)\n    //  now we can just test to see if it would normally be visible or not, provided it's\n    //  attached to the main document.\n    // NOTE: We must consider case where node is inside a shadow DOM and given directly to\n    //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.\n\n\n    if (nodeIsAttached) {\n      // this works wherever the node is: if there's at least one client rect, it's\n      //  somehow displayed; it also covers the CSS 'display: contents' case where the\n      //  node itself is hidden in place of its contents; and there's no need to search\n      //  up the hierarchy either\n      return !node.getClientRects().length;\n    } // Else, the node isn't attached to the document, which means the `getClientRects()`\n    //  API will __always__ return zero rects (this can happen, for example, if React\n    //  is used to render nodes onto a detached tree, as confirmed in this thread:\n    //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)\n    //\n    // It also means that even window.getComputedStyle(node).display will return `undefined`\n    //  because styles are only computed for nodes that are in the document.\n    //\n    // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable\n    //  somehow. Though it was never stated officially, anyone who has ever used tabbable\n    //  APIs on nodes in detached containers has actually implicitly used tabbable in what\n    //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck=\"none\"` mode -- essentially\n    //  considering __everything__ to be visible because of the innability to determine styles.\n\n  } else if (displayCheck === 'non-zero-area') {\n    // NOTE: Even though this tests that the node's client rect is non-zero to determine\n    //  whether it's displayed, and that a detached node will __always__ have a zero-area\n    //  client rect, we don't special-case for whether the node is attached or not. In\n    //  this mode, we do want to consider nodes that have a zero area to be hidden at all\n    //  times, and that includes attached or not.\n    return isZeroArea(node);\n  } // visible, as far as we can tell, or per current `displayCheck` mode\n\n\n  return false;\n}; // form fields (nested) inside a disabled fieldset are not focusable/tabbable\n//  unless they are in the _first_ <legend> element of the top-most disabled\n//  fieldset\n\n\nvar isDisabledFromFieldset = function isDisabledFromFieldset(node) {\n  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {\n    var parentNode = node.parentElement; // check if `node` is contained in a disabled <fieldset>\n\n    while (parentNode) {\n      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {\n        // look for the first <legend> among the children of the disabled <fieldset>\n        for (var i = 0; i < parentNode.children.length; i++) {\n          var child = parentNode.children.item(i); // when the first <legend> (in document order) is found\n\n          if (child.tagName === 'LEGEND') {\n            // if its parent <fieldset> is not nested in another disabled <fieldset>,\n            // return whether `node` is a descendant of its first <legend>\n            return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);\n          }\n        } // the disabled <fieldset> containing `node` has no <legend>\n\n\n        return true;\n      }\n\n      parentNode = parentNode.parentElement;\n    }\n  } // else, node's tabbable/focusable state should not be affected by a fieldset's\n  //  enabled/disabled state\n\n\n  return false;\n};\n\nvar isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {\n  if (node.disabled || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus\n  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {\n    return false;\n  }\n\n  return true;\n};\n\nvar isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(options, node) {\n  if (isNonTabbableRadio(node) || getTabindex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {\n    return false;\n  }\n\n  return true;\n};\n\nvar isValidShadowRootTabbable = function isValidShadowRootTabbable(shadowHostNode) {\n  var tabIndex = parseInt(shadowHostNode.getAttribute('tabindex'), 10);\n\n  if (isNaN(tabIndex) || tabIndex >= 0) {\n    return true;\n  } // If a custom element has an explicit negative tabindex,\n  // browsers will not allow tab targeting said element's children.\n\n\n  return false;\n};\n/**\n * @param {Array.<Element|CandidatesScope>} candidates\n * @returns Element[]\n */\n\n\nvar sortByOrder = function sortByOrder(candidates) {\n  var regularTabbables = [];\n  var orderedTabbables = [];\n  candidates.forEach(function (item, i) {\n    var isScope = !!item.scope;\n    var element = isScope ? item.scope : item;\n    var candidateTabindex = getTabindex(element, isScope);\n    var elements = isScope ? sortByOrder(item.candidates) : element;\n\n    if (candidateTabindex === 0) {\n      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        item: item,\n        isScope: isScope,\n        content: elements\n      });\n    }\n  });\n  return orderedTabbables.sort(sortOrderedTabbables).reduce(function (acc, sortable) {\n    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);\n    return acc;\n  }, []).concat(regularTabbables);\n};\n\nvar tabbable = function tabbable(el, options) {\n  options = options || {};\n  var candidates;\n\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([el], options.includeContainer, {\n      filter: isNodeMatchingSelectorTabbable.bind(null, options),\n      flatten: false,\n      getShadowRoot: options.getShadowRoot,\n      shadowRootFilter: isValidShadowRootTabbable\n    });\n  } else {\n    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));\n  }\n\n  return sortByOrder(candidates);\n};\n\nvar focusable = function focusable(el, options) {\n  options = options || {};\n  var candidates;\n\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([el], options.includeContainer, {\n      filter: isNodeMatchingSelectorFocusable.bind(null, options),\n      flatten: true,\n      getShadowRoot: options.getShadowRoot\n    });\n  } else {\n    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));\n  }\n\n  return candidates;\n};\n\nvar isTabbable = function isTabbable(node, options) {\n  options = options || {};\n\n  if (!node) {\n    throw new Error('No node provided');\n  }\n\n  if (matches.call(node, candidateSelector) === false) {\n    return false;\n  }\n\n  return isNodeMatchingSelectorTabbable(options, node);\n};\n\nvar focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');\n\nvar isFocusable = function isFocusable(node, options) {\n  options = options || {};\n\n  if (!node) {\n    throw new Error('No node provided');\n  }\n\n  if (matches.call(node, focusableCandidateSelector) === false) {\n    return false;\n  }\n\n  return isNodeMatchingSelectorFocusable(options, node);\n};\n\nexport { focusable, isFocusable, isTabbable, tabbable };\n//# sourceMappingURL=index.esm.js.map\n","/*!\n* focus-trap 6.7.1\n* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE\n*/\nimport { tabbable, isFocusable } from 'tabbable';\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar activeFocusTraps = function () {\n  var trapQueue = [];\n  return {\n    activateTrap: function activateTrap(trap) {\n      if (trapQueue.length > 0) {\n        var activeTrap = trapQueue[trapQueue.length - 1];\n\n        if (activeTrap !== trap) {\n          activeTrap.pause();\n        }\n      }\n\n      var trapIndex = trapQueue.indexOf(trap);\n\n      if (trapIndex === -1) {\n        trapQueue.push(trap);\n      } else {\n        // move this existing trap to the front of the queue\n        trapQueue.splice(trapIndex, 1);\n        trapQueue.push(trap);\n      }\n    },\n    deactivateTrap: function deactivateTrap(trap) {\n      var trapIndex = trapQueue.indexOf(trap);\n\n      if (trapIndex !== -1) {\n        trapQueue.splice(trapIndex, 1);\n      }\n\n      if (trapQueue.length > 0) {\n        trapQueue[trapQueue.length - 1].unpause();\n      }\n    }\n  };\n}();\n\nvar isSelectableInput = function isSelectableInput(node) {\n  return node.tagName && node.tagName.toLowerCase() === 'input' && typeof node.select === 'function';\n};\n\nvar isEscapeEvent = function isEscapeEvent(e) {\n  return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;\n};\n\nvar isTabEvent = function isTabEvent(e) {\n  return e.key === 'Tab' || e.keyCode === 9;\n};\n\nvar delay = function delay(fn) {\n  return setTimeout(fn, 0);\n}; // Array.find/findIndex() are not supported on IE; this replicates enough\n//  of Array.findIndex() for our needs\n\n\nvar findIndex = function findIndex(arr, fn) {\n  var idx = -1;\n  arr.every(function (value, i) {\n    if (fn(value)) {\n      idx = i;\n      return false; // break\n    }\n\n    return true; // next\n  });\n  return idx;\n};\n/**\n * Get an option's value when it could be a plain value, or a handler that provides\n *  the value.\n * @param {*} value Option's value to check.\n * @param {...*} [params] Any parameters to pass to the handler, if `value` is a function.\n * @returns {*} The `value`, or the handler's returned value.\n */\n\n\nvar valueOrHandler = function valueOrHandler(value) {\n  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    params[_key - 1] = arguments[_key];\n  }\n\n  return typeof value === 'function' ? value.apply(void 0, params) : value;\n};\n\nvar getActualTarget = function getActualTarget(event) {\n  // NOTE: If the trap is _inside_ a shadow DOM, event.target will always be the\n  //  shadow host. However, event.target.composedPath() will be an array of\n  //  nodes \"clicked\" from inner-most (the actual element inside the shadow) to\n  //  outer-most (the host HTML document). If we have access to composedPath(),\n  //  then use its first element; otherwise, fall back to event.target (and\n  //  this only works for an _open_ shadow DOM; otherwise,\n  //  composedPath()[0] === event.target always).\n  return event.target.shadowRoot && typeof event.composedPath === 'function' ? event.composedPath()[0] : event.target;\n};\n\nvar createFocusTrap = function createFocusTrap(elements, userOptions) {\n  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;\n\n  var config = _objectSpread2({\n    returnFocusOnDeactivate: true,\n    escapeDeactivates: true,\n    delayInitialFocus: true\n  }, userOptions);\n\n  var state = {\n    // @type {Array<HTMLElement>}\n    containers: [],\n    // list of objects identifying the first and last tabbable nodes in all containers/groups in\n    //  the trap\n    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap\n    //  is active, but the trap should never get to a state where there isn't at least one group\n    //  with at least one tabbable node in it (that would lead to an error condition that would\n    //  result in an error being thrown)\n    // @type {Array<{ container: HTMLElement, firstTabbableNode: HTMLElement|null, lastTabbableNode: HTMLElement|null }>}\n    tabbableGroups: [],\n    nodeFocusedBeforeActivation: null,\n    mostRecentlyFocusedNode: null,\n    active: false,\n    paused: false,\n    // timer ID for when delayInitialFocus is true and initial focus in this trap\n    //  has been delayed during activation\n    delayInitialFocusTimer: undefined\n  };\n  var trap; // eslint-disable-line prefer-const -- some private functions reference it, and its methods reference private functions, so we must declare here and define later\n\n  var getOption = function getOption(configOverrideOptions, optionName, configOptionName) {\n    return configOverrideOptions && configOverrideOptions[optionName] !== undefined ? configOverrideOptions[optionName] : config[configOptionName || optionName];\n  };\n\n  var containersContain = function containersContain(element) {\n    return !!(element && state.containers.some(function (container) {\n      return container.contains(element);\n    }));\n  };\n  /**\n   * Gets the node for the given option, which is expected to be an option that\n   *  can be either a DOM node, a string that is a selector to get a node, `false`\n   *  (if a node is explicitly NOT given), or a function that returns any of these\n   *  values.\n   * @param {string} optionName\n   * @returns {undefined | false | HTMLElement | SVGElement} Returns\n   *  `undefined` if the option is not specified; `false` if the option\n   *  resolved to `false` (node explicitly not given); otherwise, the resolved\n   *  DOM node.\n   * @throws {Error} If the option is set, not `false`, and is not, or does not\n   *  resolve to a node.\n   */\n\n\n  var getNodeForOption = function getNodeForOption(optionName) {\n    var optionValue = config[optionName];\n\n    if (typeof optionValue === 'function') {\n      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        params[_key2 - 1] = arguments[_key2];\n      }\n\n      optionValue = optionValue.apply(void 0, params);\n    }\n\n    if (!optionValue) {\n      if (optionValue === undefined || optionValue === false) {\n        return optionValue;\n      } // else, empty string (invalid), null (invalid), 0 (invalid)\n\n\n      throw new Error(\"`\".concat(optionName, \"` was specified but was not a node, or did not return a node\"));\n    }\n\n    var node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point\n\n    if (typeof optionValue === 'string') {\n      node = doc.querySelector(optionValue); // resolve to node, or null if fails\n\n      if (!node) {\n        throw new Error(\"`\".concat(optionName, \"` as selector refers to no known node\"));\n      }\n    }\n\n    return node;\n  };\n\n  var getInitialFocusNode = function getInitialFocusNode() {\n    var node = getNodeForOption('initialFocus'); // false explicitly indicates we want no initialFocus at all\n\n    if (node === false) {\n      return false;\n    }\n\n    if (node === undefined) {\n      // option not specified: use fallback options\n      if (containersContain(doc.activeElement)) {\n        node = doc.activeElement;\n      } else {\n        var firstTabbableGroup = state.tabbableGroups[0];\n        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode; // NOTE: `fallbackFocus` option function cannot return `false` (not supported)\n\n        node = firstTabbableNode || getNodeForOption('fallbackFocus');\n      }\n    }\n\n    if (!node) {\n      throw new Error('Your focus-trap needs to have at least one focusable element');\n    }\n\n    return node;\n  };\n\n  var updateTabbableNodes = function updateTabbableNodes() {\n    state.tabbableGroups = state.containers.map(function (container) {\n      var tabbableNodes = tabbable(container);\n\n      if (tabbableNodes.length > 0) {\n        return {\n          container: container,\n          firstTabbableNode: tabbableNodes[0],\n          lastTabbableNode: tabbableNodes[tabbableNodes.length - 1]\n        };\n      }\n\n      return undefined;\n    }).filter(function (group) {\n      return !!group;\n    }); // remove groups with no tabbable nodes\n    // throw if no groups have tabbable nodes and we don't have a fallback focus node either\n\n    if (state.tabbableGroups.length <= 0 && !getNodeForOption('fallbackFocus') // returning false not supported for this option\n    ) {\n      throw new Error('Your focus-trap must have at least one container with at least one tabbable node in it at all times');\n    }\n  };\n\n  var tryFocus = function tryFocus(node) {\n    if (node === false) {\n      return;\n    }\n\n    if (node === doc.activeElement) {\n      return;\n    }\n\n    if (!node || !node.focus) {\n      tryFocus(getInitialFocusNode());\n      return;\n    }\n\n    node.focus({\n      preventScroll: !!config.preventScroll\n    });\n    state.mostRecentlyFocusedNode = node;\n\n    if (isSelectableInput(node)) {\n      node.select();\n    }\n  };\n\n  var getReturnFocusNode = function getReturnFocusNode(previousActiveElement) {\n    var node = getNodeForOption('setReturnFocus', previousActiveElement);\n    return node ? node : node === false ? false : previousActiveElement;\n  }; // This needs to be done on mousedown and touchstart instead of click\n  // so that it precedes the focus event.\n\n\n  var checkPointerDown = function checkPointerDown(e) {\n    var target = getActualTarget(e);\n\n    if (containersContain(target)) {\n      // allow the click since it ocurred inside the trap\n      return;\n    }\n\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      // immediately deactivate the trap\n      trap.deactivate({\n        // if, on deactivation, we should return focus to the node originally-focused\n        //  when the trap was activated (or the configured `setReturnFocus` node),\n        //  then assume it's also OK to return focus to the outside node that was\n        //  just clicked, causing deactivation, as long as that node is focusable;\n        //  if it isn't focusable, then return focus to the original node focused\n        //  on activation (or the configured `setReturnFocus` node)\n        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,\n        //  which will result in the outside click setting focus to the node\n        //  that was clicked, whether it's focusable or not; by setting\n        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused\n        //  on activation (or the configured `setReturnFocus` node)\n        returnFocus: config.returnFocusOnDeactivate && !isFocusable(target)\n      });\n      return;\n    } // This is needed for mobile devices.\n    // (If we'll only let `click` events through,\n    // then on mobile they will be blocked anyways if `touchstart` is blocked.)\n\n\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      // allow the click outside the trap to take place\n      return;\n    } // otherwise, prevent the click\n\n\n    e.preventDefault();\n  }; // In case focus escapes the trap for some strange reason, pull it back in.\n\n\n  var checkFocusIn = function checkFocusIn(e) {\n    var target = getActualTarget(e);\n    var targetContained = containersContain(target); // In Firefox when you Tab out of an iframe the Document is briefly focused.\n\n    if (targetContained || target instanceof Document) {\n      if (targetContained) {\n        state.mostRecentlyFocusedNode = target;\n      }\n    } else {\n      // escaped! pull it back in to where it just left\n      e.stopImmediatePropagation();\n      tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());\n    }\n  }; // Hijack Tab events on the first and last focusable nodes of the trap,\n  // in order to prevent focus from escaping. If it escapes for even a\n  // moment it can end up scrolling the page and causing confusion so we\n  // kind of need to capture the action at the keydown phase.\n\n\n  var checkTab = function checkTab(e) {\n    var target = getActualTarget(e);\n    updateTabbableNodes();\n    var destinationNode = null;\n\n    if (state.tabbableGroups.length > 0) {\n      // make sure the target is actually contained in a group\n      // NOTE: the target may also be the container itself if it's tabbable\n      //  with tabIndex='-1' and was given initial focus\n      var containerIndex = findIndex(state.tabbableGroups, function (_ref) {\n        var container = _ref.container;\n        return container.contains(target);\n      });\n\n      if (containerIndex < 0) {\n        // target not found in any group: quite possible focus has escaped the trap,\n        //  so bring it back in to...\n        if (e.shiftKey) {\n          // ...the last node in the last group\n          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;\n        } else {\n          // ...the first node in the first group\n          destinationNode = state.tabbableGroups[0].firstTabbableNode;\n        }\n      } else if (e.shiftKey) {\n        // REVERSE\n        // is the target the first tabbable node in a group?\n        var startOfGroupIndex = findIndex(state.tabbableGroups, function (_ref2) {\n          var firstTabbableNode = _ref2.firstTabbableNode;\n          return target === firstTabbableNode;\n        });\n\n        if (startOfGroupIndex < 0 && state.tabbableGroups[containerIndex].container === target) {\n          // an exception case where the target is the container itself, in which\n          //  case, we should handle shift+tab as if focus were on the container's\n          //  first tabbable node, and go to the last tabbable node of the LAST group\n          startOfGroupIndex = containerIndex;\n        }\n\n        if (startOfGroupIndex >= 0) {\n          // YES: then shift+tab should go to the last tabbable node in the\n          //  previous group (and wrap around to the last tabbable node of\n          //  the LAST group if it's the first tabbable node of the FIRST group)\n          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;\n          var destinationGroup = state.tabbableGroups[destinationGroupIndex];\n          destinationNode = destinationGroup.lastTabbableNode;\n        }\n      } else {\n        // FORWARD\n        // is the target the last tabbable node in a group?\n        var lastOfGroupIndex = findIndex(state.tabbableGroups, function (_ref3) {\n          var lastTabbableNode = _ref3.lastTabbableNode;\n          return target === lastTabbableNode;\n        });\n\n        if (lastOfGroupIndex < 0 && state.tabbableGroups[containerIndex].container === target) {\n          // an exception case where the target is the container itself, in which\n          //  case, we should handle tab as if focus were on the container's\n          //  last tabbable node, and go to the first tabbable node of the FIRST group\n          lastOfGroupIndex = containerIndex;\n        }\n\n        if (lastOfGroupIndex >= 0) {\n          // YES: then tab should go to the first tabbable node in the next\n          //  group (and wrap around to the first tabbable node of the FIRST\n          //  group if it's the last tabbable node of the LAST group)\n          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;\n\n          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];\n          destinationNode = _destinationGroup.firstTabbableNode;\n        }\n      }\n    } else {\n      // NOTE: the fallbackFocus option does not support returning false to opt-out\n      destinationNode = getNodeForOption('fallbackFocus');\n    }\n\n    if (destinationNode) {\n      e.preventDefault();\n      tryFocus(destinationNode);\n    } // else, let the browser take care of [shift+]tab and move the focus\n\n  };\n\n  var checkKey = function checkKey(e) {\n    if (isEscapeEvent(e) && valueOrHandler(config.escapeDeactivates, e) !== false) {\n      e.preventDefault();\n      trap.deactivate();\n      return;\n    }\n\n    if (isTabEvent(e)) {\n      checkTab(e);\n      return;\n    }\n  };\n\n  var checkClick = function checkClick(e) {\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      return;\n    }\n\n    var target = getActualTarget(e);\n\n    if (containersContain(target)) {\n      return;\n    }\n\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      return;\n    }\n\n    e.preventDefault();\n    e.stopImmediatePropagation();\n  }; //\n  // EVENT LISTENERS\n  //\n\n\n  var addListeners = function addListeners() {\n    if (!state.active) {\n      return;\n    } // There can be only one listening focus trap at a time\n\n\n    activeFocusTraps.activateTrap(trap); // Delay ensures that the focused element doesn't capture the event\n    // that caused the focus trap activation.\n\n    state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function () {\n      tryFocus(getInitialFocusNode());\n    }) : tryFocus(getInitialFocusNode());\n    doc.addEventListener('focusin', checkFocusIn, true);\n    doc.addEventListener('mousedown', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('touchstart', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('click', checkClick, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('keydown', checkKey, {\n      capture: true,\n      passive: false\n    });\n    return trap;\n  };\n\n  var removeListeners = function removeListeners() {\n    if (!state.active) {\n      return;\n    }\n\n    doc.removeEventListener('focusin', checkFocusIn, true);\n    doc.removeEventListener('mousedown', checkPointerDown, true);\n    doc.removeEventListener('touchstart', checkPointerDown, true);\n    doc.removeEventListener('click', checkClick, true);\n    doc.removeEventListener('keydown', checkKey, true);\n    return trap;\n  }; //\n  // TRAP DEFINITION\n  //\n\n\n  trap = {\n    activate: function activate(activateOptions) {\n      if (state.active) {\n        return this;\n      }\n\n      var onActivate = getOption(activateOptions, 'onActivate');\n      var onPostActivate = getOption(activateOptions, 'onPostActivate');\n      var checkCanFocusTrap = getOption(activateOptions, 'checkCanFocusTrap');\n\n      if (!checkCanFocusTrap) {\n        updateTabbableNodes();\n      }\n\n      state.active = true;\n      state.paused = false;\n      state.nodeFocusedBeforeActivation = doc.activeElement;\n\n      if (onActivate) {\n        onActivate();\n      }\n\n      var finishActivation = function finishActivation() {\n        if (checkCanFocusTrap) {\n          updateTabbableNodes();\n        }\n\n        addListeners();\n\n        if (onPostActivate) {\n          onPostActivate();\n        }\n      };\n\n      if (checkCanFocusTrap) {\n        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);\n        return this;\n      }\n\n      finishActivation();\n      return this;\n    },\n    deactivate: function deactivate(deactivateOptions) {\n      if (!state.active) {\n        return this;\n      }\n\n      clearTimeout(state.delayInitialFocusTimer); // noop if undefined\n\n      state.delayInitialFocusTimer = undefined;\n      removeListeners();\n      state.active = false;\n      state.paused = false;\n      activeFocusTraps.deactivateTrap(trap);\n      var onDeactivate = getOption(deactivateOptions, 'onDeactivate');\n      var onPostDeactivate = getOption(deactivateOptions, 'onPostDeactivate');\n      var checkCanReturnFocus = getOption(deactivateOptions, 'checkCanReturnFocus');\n\n      if (onDeactivate) {\n        onDeactivate();\n      }\n\n      var returnFocus = getOption(deactivateOptions, 'returnFocus', 'returnFocusOnDeactivate');\n\n      var finishDeactivation = function finishDeactivation() {\n        delay(function () {\n          if (returnFocus) {\n            tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));\n          }\n\n          if (onPostDeactivate) {\n            onPostDeactivate();\n          }\n        });\n      };\n\n      if (returnFocus && checkCanReturnFocus) {\n        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);\n        return this;\n      }\n\n      finishDeactivation();\n      return this;\n    },\n    pause: function pause() {\n      if (state.paused || !state.active) {\n        return this;\n      }\n\n      state.paused = true;\n      removeListeners();\n      return this;\n    },\n    unpause: function unpause() {\n      if (!state.paused || !state.active) {\n        return this;\n      }\n\n      state.paused = false;\n      updateTabbableNodes();\n      addListeners();\n      return this;\n    },\n    updateContainerElements: function updateContainerElements(containerElements) {\n      var elementsAsArray = [].concat(containerElements).filter(Boolean);\n      state.containers = elementsAsArray.map(function (element) {\n        return typeof element === 'string' ? doc.querySelector(element) : element;\n      });\n\n      if (state.active) {\n        updateTabbableNodes();\n      }\n\n      return this;\n    }\n  }; // initialize container elements\n\n  trap.updateContainerElements(elements);\n  return trap;\n};\n\nexport { createFocusTrap };\n//# sourceMappingURL=focus-trap.esm.js.map\n","import * as focusTrap from \"focus-trap\";\n\nconst addFocusTrap = (arg): any => {\n    const {\n        target,\n        escapeDeactivates = (e) => false,\n        clickOutsideDeactivates = (e) => false,\n    } = arg;\n\n    const ft = focusTrap.createFocusTrap(target, {\n        // initialFocus: false,\n        delayInitialFocus: false,\n        escapeDeactivates,\n        clickOutsideDeactivates,\n    });\n    ft.activate();\n    return ft;\n};\n\nexport default addFocusTrap;\n","const hasFocussableElements = (root: Element): boolean => {\n    let focusableEls = [].slice.call(root.querySelectorAll('[autofocus], [tabindex], a, input, textarea, select, button'));\n\n    focusableEls = focusableEls.filter((el: HTMLElement) => {\n        const isDisabledOrHidden = el.getAttribute('aria-disabled') === 'true' ||\n            el.getAttribute('disabled') != null ||\n            el.getAttribute('hidden') != null ||\n            el.getAttribute('aria-hidden') === 'true';\n        const isTabbableAndVisible = el.tabIndex >= 0 &&\n            el.getBoundingClientRect().width > 0 &&\n            !isDisabledOrHidden;\n        let isProgrammaticallyHidden = false;\n        if (isTabbableAndVisible) {\n            const style = getComputedStyle(el);\n            isProgrammaticallyHidden =\n                style.display === 'none' || style.visibility === 'hidden';\n        }\n        return isTabbableAndVisible && !isProgrammaticallyHidden;\n    });\n\n    return focusableEls.length > 0;\n};\n\nexport default hasFocussableElements;\n","function debounce<T>(\n  fn: (arg: T) => void,\n  ms: number\n): (arg: T) => void {\n  // Avoid wrapping in `setTimeout` if ms is 0 anyway\n  if (ms === 0) {\n    return fn;\n  }\n\n  let timeout: any;\n\n  return (arg): void => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => {\n      fn(arg);\n    }, ms);\n  };\n}\n\nexport default debounce;\n","export default (obj: Object) => JSON.parse(JSON.stringify(obj));\n","export const MODAL_OVERLAY_CLASS = \"lusift-modal-overlay\";\nexport const PROGRESS_BAR_CLASS = \"lusift-progress\";\nexport const MODAL_CLASS = \"modal\";\nexport const BEACON_CONTAINER_CLASS = \"lusift-beacon-container\";\nexport const DEFAULT_TOOLTIP_BORDER_RADIUS = \"4px\";\nexport const DEFAULT_MODAL_BORDER_RADIUS = \"4px\";\nexport const PRIMARY_COLOR = \"#17a3a8\";\nexport const DEFAULT_PROGRESS_BAR_HEIGHT = \"3px\";\nexport const LUSIFT_CONTAINER_ID = \"lusift\";\nexport const LUSIFT_SHADOW_ROOT_ID = \"lusift-root\";\nexport const MODAL_OVERLAY_Z_INDEX = 99999;\nexport const TOOLTIP_Z_INDEX = 99999;\nexport const BACKDROP_Z_INDEX = TOOLTIP_Z_INDEX - 1;\nexport const BEACON_Z_INDEX = 99999;\nexport const OVERLAY_SELECTOR_CLASS = \"lusift-backdrop-overlay\";\n","import { window } from \"global\";\nimport { loadState } from \"../store\";\nimport {\n    DEFAULT_TOOLTIP_BORDER_RADIUS,\n    DEFAULT_MODAL_BORDER_RADIUS,\n    PRIMARY_COLOR,\n    DEFAULT_PROGRESS_BAR_HEIGHT,\n    PROGRESS_BAR_CLASS\n} from \"../constants\";\n\n// TODO: Add progress bar to content object\n\nconst renderProgressBar = () => {\n    const currentGuide = loadState()[window.Lusift.getActiveGuide()?.id];\n\n    if (!currentGuide) return \"\";\n    if (!currentGuide) {\n        // Assuming that this is dev mode\n        let progress = \"66.66\";\n        let max = 100;\n        return `\n        <progress class=\"lusift-progress\" aria-label=\"progressbar\" max=\"${max}\" value=\"${progress}\">\n        ${progress}%\n        </progress>\n        `;\n    }\n\n    const Lusift = window['Lusift'];\n    const guideData = Lusift.getContent()[Lusift.getActiveGuide().id].data;\n    const currentStep = guideData.steps[currentGuide.trackingState.currentStepIndex];\n    const progressBarData = currentGuide.progressBar || {};\n\n    // find out borderRadius based on step type (their default border radii), or via styleProps\n    // TODO: add styleProps object to content, and see how to consume it\n    // -- do the same for beacon btw\n    let {\n        height = DEFAULT_PROGRESS_BAR_HEIGHT,\n        backgroundColor = PRIMARY_COLOR,\n        borderRadius,\n    } = progressBarData;\n\n    // TODO: Better way to retrieve borderRadius from tooltip dom element?\n    if (!borderRadius) {\n        if (currentStep.type === \"modal\") {\n            if (currentStep.styleProps) {\n                borderRadius = currentStep.styleProps.borderRadius || DEFAULT_MODAL_BORDER_RADIUS;\n            } else {\n                borderRadius = DEFAULT_MODAL_BORDER_RADIUS;\n            }\n        } else {\n            if (currentStep.styleProps) {\n                borderRadius = currentStep.styleProps.borderRadius || DEFAULT_TOOLTIP_BORDER_RADIUS;\n            } else {\n                borderRadius = DEFAULT_TOOLTIP_BORDER_RADIUS;\n            }\n        }\n    }\n\n    const progress = Lusift.getActiveGuide().instance.getProgress();\n\n    const max = 100;\n\n    const progressBarElement = document.createElement(\"progress\");\n    progressBarElement.classList.add(PROGRESS_BAR_CLASS);\n    progressBarElement.setAttribute(\"aria-label\", \"progressbar\");\n    progressBarElement.setAttribute(\"max\", `${max}`);\n    progressBarElement.setAttribute(\"value\", progress);\n    // move style rules to parent (tooltip or modal)\n    return progressBarElement;\n};\n\nexport default renderProgressBar;\n","import { styleObjectToString } from \"../utils\";\n\nconst renderCloseXButton = (closeButton: any, stepType: 'modal' | 'tooltip'): string => {\n  if (closeButton.disabled) return '';\n  return `\n    <style>\n    .lusift .${stepType.toLowerCase()} .closeX{\n      ${styleObjectToString(closeButton.styleProps)}\n    }\n    </style>\n\n    <button onclick=\"Lusift.close()\" class=\"closeX close\">\n      &#10799;\n    </button>\n  `;\n};\n\nexport default renderCloseXButton;\n","!function(t,e){\"object\"==typeof exports&&\"undefined\"!=typeof module?e(exports,require(\"tslib\"),require(\"@floating-ui/dom\")):\"function\"==typeof define&&define.amd?define([\"exports\",\"tslib\",\"@floating-ui/dom\"],e):e((t=\"undefined\"!=typeof globalThis?globalThis:t||self)[\"floating-ui-tooltip\"]={},t.tslib,t.dom)}(this,(function(t,e,i){\"use strict\";function n(t,e,i){var n=e+\"EventListener\";[\"transitionend\",\"webkitTransitionEnd\",\"oTransitionEnd\"].forEach((function(e){t[n](e,i)}))}function o(t,e){t.setAttribute(\"data-transition-state\",e)}function r(t,e){t.setAttribute(\"data-state\",e),Object.assign(t.style,{visibility:e})}function s(){return document.createElement(\"div\")}function a(t){return{box:t.querySelector(\".floating-ui-tooltip-box\"),content:t.querySelector(\".floating-ui-tooltip-content\"),arrow:t.querySelector(\".floating-ui-tooltip-arrow\")||void 0}}var l,d=function(t,e,i){var n=i||100;clearTimeout(l),l=setTimeout((function(){p(t,e)}),n)};function p(t,e){!function(t){clearTimeout(t)}(l);var i=t._instance,s=i.props.updateDebounce,a=t.getAttribute(\"data-transition-state\");if(\"visible\"===e){if(\"shown\"===a||\"showing\"===a)return;if(\"hidden\"===a)o(t,\"showing\");else if(\"hiding\"===a)return void d(t,e,s)}else{if(\"hidden\"===a||\"hiding\"===a)return;if(\"shown\"===a)o(t,\"hiding\"),i.props.onHide(i);else if(\"showing\"===a)return void d(t,e,s)}var p=\"visible\"===e?\"shown\":\"hidden\";0!==i.transitionDuration?(!function(t,e){function i(o){if(o.target===t){n(t,\"remove\",i);try{e()}catch(e){console.error(e),t._instance.props.onHide()}}}n(t,\"remove\",i),n(t,\"add\",i)}(t,(function(){!function(t,e){t._instance.setState({isShown:\"visible\"===e})}(t,e),o(t,p),\"visible\"===e&&i.props.onShow(i)})),r(t,e)):(r(t,e),o(t,p),\"visible\"===e&&i.props.onShow(i))}var c={top:\"bottom\",right:\"left\",bottom:\"top\",left:\"right\"},u=function(t){var e,i,n,o=t.passedPlacement,r=t.tooltipElement,s=t.toResetPosition,a=o.orientation,l=null===(e=r._instance.state.fui)||void 0===e?void 0:e.placement;return l?s?(i=r.getBoundingClientRect(),n=document.documentElement.getBoundingClientRect(),(i.top<n.top||i.bottom>n.bottom||i.left<n.left||i.right>n.right)&&(console.log(\"tooltip overflown\"),\"auto\"===a)?\"auto\":l):l:o.position},h=function(t){var n=t.passedPlacement,o=t.toResetPosition,r=t.passedOffset,s=t.resetPlacementOnUpdate,a=t.newlyShown,l=t.toShift,d=t.toShowArrow,p=t.arrowElement,c=t.tooltipElement,h=t.target;return e.__awaiter(void 0,void 0,void 0,(function(){var t,f,w,g;return e.__generator(this,(function(m){switch(m.label){case 0:return t=u({passedPlacement:n,tooltipElement:c,toResetPosition:o}),f=\"auto\"===t&&(a||s),w=l&&a,g=e.__assign(e.__assign({},\"auto\"!==t&&{placement:t}),{middleware:e.__spreadArray(e.__spreadArray(e.__spreadArray(e.__spreadArray([i.offset({mainAxis:r[0],crossAxis:r[1]})],f?[i.autoPlacement()]:[],!0),w?[i.shift({padding:16})]:[],!0),d?[i.arrow({element:p,padding:2})]:[],!0),[i.size({apply:function(t){t.width,t.height,t.reference,t.floating}}),i.hide()],!1)}),[4,i.computePosition(h,c,g)];case 1:return[2,m.sent()]}}))}))},f=function(t,i,n,o,r,s){return e.__awaiter(void 0,void 0,void 0,(function(){var l,d,u,f,w,g,m,v,b,x,_,y,E,S;return e.__generator(this,(function(e){switch(e.label){case 0:return d=void 0===(l={}.toShift)||l,u=t.placement,f=t.hideOnReferenceHidden,w=t.offset,g=t.hideOnTooltipEscape,m=t.arrowSizeScale,v=t.resetPlacementOnUpdate,b=t.arrow,x=t.scrollIntoView,_=t.showOnCreate,y=a(i).arrow,E=!i._instance.getState().fui,n?[4,h({passedPlacement:u,toResetPosition:r,passedOffset:w,resetPlacementOnUpdate:v,toShift:d,toShowArrow:b,arrowElement:y,tooltipElement:i,target:n,newlyShown:E})]:[2,console.warn(\"target element not found\")];case 1:return function(t){var e,i,n,o=t.fui,r=t.newlyShown,s=t.scrollIntoView,a=t.hideOnReferenceHidden,l=t.hideOnTooltipEscape,d=t.tooltipElement,u=t.arrowElement,h=t.target,f=t.toHide,w=t.showOnCreate,g=t.arrowSizeScale,m=o.x,v=o.y,b=o.placement,x=o.middlewareData,_=x.hide,y=_.referenceHidden,E=_.escaped;y&&r&&s&&h.scrollIntoView({behavior:\"smooth\",block:\"center\",inline:\"center\"}),x.arrow&&(i=x.arrow.x,n=x.arrow.y);var S=0!==x.arrow.centerOffset,O=a&&y||l&&E||f?\"hidden\":\"visible\";\"visible\"===O&&r&&!w&&(O=\"hidden\"),p(d,O),Object.assign(d.style,{left:m+\"px\",top:v+\"px\"});var T=12*g,C=c[b.split(\"-\")[0]],k=0,H=0,A=0;switch(A=null!==i?i+T+\"px\":\"\",C){case\"top\":k=1/1.7,k=.5,A=null!==i?i+T*k+\"px\":\"\";break;case\"bottom\":k=.5,A=null!==i?i+T*k+\"px\":\"\";break;case\"left\":k=.005,A=null!==i?i+\"px\":\"\",H=null!==n?n-T*k/2+\"px\":\"\";break;case\"right\":k=1,A=null!==i?i+\"px\":\"\",H=null!==n?n-T*k/2+\"px\":\"\"}H=null!==n?n-T*k/2+\"px\":\"\",H=null!==n?n+\"px\":\"\",Object.assign(u.style,((e={visibility:S?\"hidden\":\"visible\",left:A,top:H,right:\"\",bottom:\"\",width:T+\"px\",height:T+\"px\"})[C]=\"-\"+T*k+\"px\",e))}({fui:S=e.sent(),newlyShown:E,scrollIntoView:x,hideOnReferenceHidden:f,hideOnTooltipEscape:g,tooltipElement:i,arrowElement:y,target:n,toHide:o,showOnCreate:_,arrowSizeScale:m}),s({fui:S}),[2,S]}}))}))},w={allowHTML:!0,content:\"\",arrow:!0,scrollIntoView:!1,transitionDuration:[300,250],offset:[0,0],factorArrowInOffset:!0,hideOnClick:!0,onClickOutside:function(t,e){},onShow:function(t){},onHide:function(t){},onStateChange:function(t,e){},onRemove:function(){},onBeforeFirstRender:function(){},onAfterFirstRender:function(){},placement:{position:\"top\",orientation:\"fixed\"},resetPlacementOnUpdate:!1,hideOnTooltipEscape:!0,hideOnReferenceHidden:!0,showOnCreate:!0,maxWidth:350,updateDebounce:100,zIndex:99999,arrowSizeScale:1,updateOnEvents:\"resize scroll\"};var g=function(){function t(t,e){var i,n=this;this.state={isShown:!1,isRemoved:!1,fui:void 0},this.updateListenerCleanup=function(){},this.toHideTooltip=!1,this.transitionDuration=0,this.clickHandler=function(t){n.state.isShown&&(n.tooltipElement.contains(t.target)||n.reference.contains(t.target)||n.props.onClickOutside&&n.props.onClickOutside(n,t),\"target\"===n.props.hideOnClick?t.target===n.reference&&n.hide():n.props.hideOnClick&&n.hide())},this.props=t,this.reference=e,window.tp=this,(i=document.createElement(\"style\")).type=\"text/css\",i.setAttribute(\"floating-ui-tooltip-default\",\"\"),i.textContent=\".floating-ui-tooltip-root{--color:#fff;--border-color:#fefefe;--border-color:red;backface-visibility:hidden;background:var(--color);border-radius:6px;box-shadow:0 0 0 1px rgba(6,44,82,.1),0 2px 16px rgba(33,43,54,.08);box-shadow:0 0 20px 4px rgba(154,161,177,.15),0 4px 80px -8px rgba(36,40,47,.25),0 4px 4px -2px rgba(91,94,105,.15);display:flex;font-size:90%;line-height:0px;margin:0;max-width:calc(100vw - 10px);padding:0;position:absolute;transition-duration:.2s;transition-property:transform,visibility,opacity;transition-timing-function:cubic-bezier(.54,1.5,.38,1.11);z-index:9999}.floating-ui-tooltip-arrow{box-shadow:0 0 0 1px rgba(6,44,82,.1),0 2px 16px rgba(33,43,54,.08);height:14px;position:absolute;transform:translateX(-50%) rotate(45deg);width:14px;z-index:-1}.floating-ui-tooltip-box{border-radius:inherit;line-height:normal;margin:0;outline:0;position:relative}.floating-ui-tooltip-root[data-state=hidden]{opacity:0}.floating-ui-tooltip-root[data-state=visible]{opacity:1}.floating-ui-tooltip-content{background-color:#fff;border-radius:inherit;color:#111;padding:0;position:relative;z-index:2}.floating-ui-tooltip-arrow,.floating-ui-tooltip-root{background:var(--color)}\",document.head.appendChild(i),this.toHideTooltip=!this.props.showOnCreate}return t.prototype.hookEventListeners=function(){var t=this;this.debouncedUpdate=function(t,e){return 0===e?t:function(n){clearTimeout(i),i=setTimeout((function(){t(n)}),e)};var i}(this.update.bind(this),this.props.updateDebounce);var e=i.autoUpdate(this.reference,this.tooltipElement,(function(){return t.debouncedUpdate(void 0)})),n=function(){return t.debouncedUpdate(void 0)};this.props.updateOnEvents.split(\" \").forEach((function(t){window.addEventListener(t,n)})),window.addEventListener(\"click\",this.clickHandler.bind(this)),this.updateListenerCleanup=function(){e(),window.removeEventListener(\"click\",t.clickHandler.bind(t)),t.props.updateOnEvents.split(\" \").forEach((function(t){window.removeEventListener(t,n)}))}},t.prototype.updateTransitionDuration=function(t){this.transitionDuration=t,this.tooltipElement.style.transitionDuration=t+\"ms\"},t.prototype.create=function(){return e.__awaiter(this,void 0,void 0,(function(){var t,i,n,l,d,p=this;return e.__generator(this,(function(c){switch(c.label){case 0:return this.tooltipElement=(u=this,h=s(),w=s(),g=s(),m=s(),h.className=\"floating-ui-tooltip-root\",w.className=\"floating-ui-tooltip-box\",g.className=\"floating-ui-tooltip-content\",m.className=\"floating-ui-tooltip-arrow\",w.appendChild(g),w.appendChild(m),h.appendChild(w),Object.assign(g.style,{maxWidth:u.props.maxWidth+\"px\"}),w.setAttribute(\"role\",\"tooltip\"),r(h,\"hidden\"),o(h,\"hidden\"),Object.assign(h.style,{zIndex:u.props.zIndex,visibility:\"hidden\",left:\"0px\",top:\"0px\"}),h._instance=u,h),this.updateTransitionDuration(this.props.transitionDuration[this.toHideTooltip?0:1]),t=a(this.tooltipElement).content,i=this.props,n=i.allowHTML,l=i.content,n?l instanceof Element?t.appendChild(l):t.innerHTML=l:l instanceof Element||(t.innerText=l),document.body.appendChild(this.tooltipElement),this.props.onBeforeFirstRender(),d=function(){return e.__awaiter(p,void 0,void 0,(function(){return e.__generator(this,(function(t){switch(t.label){case 0:return[4,f(this.props,this.tooltipElement,this.reference,this.toHideTooltip,!0,this.setState.bind(this))];case 1:case 2:return t.sent(),[4,this.update(!1,!0)];case 3:return t.sent(),this.hookEventListeners(),[2]}}))}))},[4,d()];case 1:return c.sent(),this.props.showOnCreate?[4,this.show()]:[3,3];case 2:return c.sent(),[3,5];case 3:return[4,this.hide()];case 4:c.sent(),c.label=5;case 5:return this.props.onAfterFirstRender(),[2]}var u,h,w,g,m}))}))},t.prototype.getState=function(){return this.state},t.prototype.setState=function(t){void 0!==t.isShown&&t.isShown!==this.state.isShown&&this.updateTransitionDuration(this.props.transitionDuration[t.isShown?1:0]),this.props.onStateChange(this.state,t),this.state=e.__assign(e.__assign({},this.state),t)},t.prototype.update=function(t,i){return e.__awaiter(this,void 0,void 0,(function(){return e.__generator(this,(function(e){switch(e.label){case 0:return t=t||this.toHideTooltip||!1,[4,f(this.props,this.tooltipElement,this.reference,t,i,this.setState.bind(this))];case 1:return e.sent(),[2]}}))}))},t.prototype.hide=function(){return e.__awaiter(this,void 0,void 0,(function(){return e.__generator(this,(function(t){switch(t.label){case 0:return this.toHideTooltip=!0,[4,this.update(!0)];case 1:return t.sent(),[2]}}))}))},t.prototype.show=function(){return e.__awaiter(this,void 0,void 0,(function(){return e.__generator(this,(function(t){switch(t.label){case 0:return this.toHideTooltip=!1,[4,this.update(!1)];case 1:return t.sent(),[2]}}))}))},t.prototype.remove=function(){this.tooltipElement.remove(),this.state={isShown:!1,isRemoved:!0,fui:void 0},this.updateListenerCleanup(),console.log(\"removed all event listeners and observers\"),this.props.onRemove()},t}();t.DEFAULT_ARROW_SIZE=12,t.default=function(t,i){return e.__awaiter(this,void 0,void 0,(function(){var n,o,r,s,a,l;return e.__generator(this,(function(d){switch(d.label){case 0:return n=i.placement||w.placement,o=i.transitionDuration||w.transitionDuration,r=i.offset||w.offset,Object.keys(i).forEach((function(t){return void 0===i[t]&&delete i[t]})),(s=e.__assign(e.__assign(e.__assign({},w),i),{placement:n,transitionDuration:o,offset:r})).factorArrowInOffset=s.arrow&&s.factorArrowInOffset,s.factorArrowInOffset&&(a=12*s.arrowSizeScale,s.offset[0]=s.offset[0]+a*Math.sqrt(2)/2),[4,(l=new g(s,t)).create()];case 1:return d.sent(),[2,{props:l.props,reference:l.reference,tooltipElement:l.tooltipElement,getState:l.getState.bind(l),show:l.show.bind(l),hide:l.hide.bind(l),remove:l.remove.bind(l),update:l.update.bind(l)}]}}))}))},Object.defineProperty(t,\"__esModule\",{value:!0})}));\n//# sourceMappingURL=index.js.map\n","/* import floatingTooltip from 'floating-ui-tooltip/dev/index';\nimport { Instance } from 'floating-ui-tooltip/dev/types'; */\nimport floatingTooltip from 'floating-ui-tooltip';\nimport { Instance, Props } from 'floating-ui-tooltip/dist/types';\nimport { TOOLTIP_Z_INDEX } from '../common/constants';\n\nconst createTooltip = async (props): Promise<Instance> => {\n\n    let {\n        target,\n        remove,\n        arrowSizeScale,\n        content,\n        arrow,\n        maxWidth,\n        offset,\n        placement,\n        onShow,\n        onHide,\n        onBeforeFirstRender,\n        onAfterFirstRender,\n        showOnCreate,\n        onClickOutside,\n        hideOnReferenceHidden,\n        hideOnTooltipEscape,\n        scrollIntoView\n    } = props;\n\n    if (!remove) {\n        remove = () => {};\n    }\n\n    return floatingTooltip(target, {\n        allowHTML: true,\n        zIndex: TOOLTIP_Z_INDEX,\n        hideOnClick: false,\n        onClickOutside,\n        onShow,\n        arrowSizeScale,\n        onHide,\n        onBeforeFirstRender,\n        onAfterFirstRender,\n        content,\n        hideOnReferenceHidden,\n        hideOnTooltipEscape,\n        arrow,\n        maxWidth,\n        offset,\n        placement,\n        showOnCreate,\n        scrollIntoView\n    });\n};\n\nexport default createTooltip;\n","import renderProgressBar from \"../common/progressBar\";\nimport renderCloseXButton from \"../common/closeXButton\";\nimport createTooltip from \"../common/createTooltip\";\nimport { DEFAULT_TOOLTIP_BORDER_RADIUS } from \"../common/constants\";\nimport { styleObjectToString } from '../common/utils';\nimport { log } from \"../common/logger\";\n\nconst defaultBodyContent = `\n  <h3 style=\"font-weight: bold;\">Default title</h3>\n  <p style=\"font-weight: normal;\">Default tooltip content</p>\n`;\n// TODO: The progress bar should look like it's contained rather than floating on top\n\nconst div = () => document.createElement(\"div\");\nconst section = () => document.createElement(\"section\");\nconst button = () => document.createElement(\"button\");\n\n\nconst renderFooter = (navSection: any): Element => {\n    const { nextButton, prevButton, dismissLink, disabled } = navSection;\n    if (disabled) return div();\n\n    const container = section();\n    container.className = 'nav-buttons';\n    const dismiss = button();\n    dismiss.className = 'close dismiss-link';\n    dismiss.innerText = dismissLink.text;\n    dismiss.setAttribute('onclick', 'window.Lusift.close()');\n\n    const prev = button();\n    prev.className = 'prev';\n    prev.innerText = prevButton.text;\n    prev.setAttribute('onclick', 'window.Lusift.prev()');\n    const next = button();\n    next.className = 'next lusift-button';\n    next.innerText = nextButton.text;\n    next.setAttribute('onclick', 'window.Lusift.next()');\n\n    Object.assign(dismiss.style, dismissLink.styleProps);\n    Object.assign(next.style, nextButton.styleProps);\n    Object.assign(prev.style, prevButton.styleProps);\n\n    const prevNextBtns = div();\n    prevNextBtns.className = 'prev-next-btns';\n\n    dismissLink && container.appendChild(dismiss);\n    prevButton && prevNextBtns.appendChild(prev);\n    nextButton && prevNextBtns.appendChild(next);\n    container.appendChild(prevNextBtns);\n\n    return container;\n};\n\nconst renderNavButtons = (navSection: any): Element => {\n    const { nextButton, prevButton, dismissLink, disabled } = navSection;\n    if (disabled) return div();\n\n    const container = section();\n    container.className = 'nav-buttons';\n    const dismiss = document.createElement('button');\n    dismiss.className = 'close dismiss-link';\n    dismiss.innerText = dismissLink.text;\n    dismiss.setAttribute('onclick', 'window.Lusift.close()');\n\n    const prev = document.createElement('button');\n    prev.className = 'prev';\n    prev.innerText = prevButton.text;\n    prev.setAttribute('onclick', 'window.Lusift.prev()');\n    const next = document.createElement('button');\n    next.className = 'next lusift-button';\n    next.innerText = nextButton.text;\n    next.setAttribute('onclick', 'window.Lusift.next()');\n\n    Object.assign(dismiss.style, dismissLink.styleProps);\n    Object.assign(next.style, nextButton.styleProps);\n    Object.assign(prev.style, prevButton.styleProps);\n\n    dismissLink && container.appendChild(dismiss);\n    prevButton && container.appendChild(prev);\n    nextButton && container.appendChild(next);\n\n    return container;\n};\n\nconst renderTooltip = async ({ data, target, styleProps, actions, uid, index, onShow, onHide, scrollIntoView }) => {\n  const { closeButton, navSection } = actions;\n  const {\n    arrow,\n    // bodyContent = defaultBodyContent,\n    placement,\n    offset,\n    maxWidth,\n    progressBar,\n    arrowSizeScale\n  } = data;\n\n  const content = div();\n  content.className = 'lusift';\n\n  content.innerHTML = `\n      <style>\n      .lusift-progress {\n        ${styleObjectToString({\n          ...progressBar.styleProps,\n          backgroundColor: undefined\n        })}\n      }\n      .lusift-progress::-webkit-progress-bar {\n        ${styleObjectToString({\n          ...progressBar.styleProps,\n          backgroundColor: undefined\n        })}\n      }\n      .lusift-progress::-webkit-progress-value {\n        ${styleObjectToString(progressBar.styleProps)}\n      }\n\n      .lusift-progress::-moz-progress-bar {\n          initial: none;\n        ${styleObjectToString({\n          ...progressBar.styleProps,\n          backgroundColor: undefined\n        })}\n      }\n      </style>\n    <div aria-label=\"tooltip\" class=\"tooltip\" id=\"tooltip-${uid}\">\n      ${renderCloseXButton(closeButton, \"tooltip\")}\n      <section class=\"body-content\">\n      </section>\n      <section class=\"footer\">\n      </section>\n    </div>\n  `;\n  if (!progressBar.disabled) {\n    content.prepend(renderProgressBar());\n  }\n  content.querySelector(`#tooltip-${uid}`)!.appendChild(renderFooter(navSection));\n\n  Object.assign(content.style, {\n    borderRadius: DEFAULT_TOOLTIP_BORDER_RADIUS,\n    ...styleProps\n  })\n\n  const Lusift = window[\"Lusift\"];\n\n  let bodyContent = defaultBodyContent;\n  let footerContent = null;\n  const activeGuide = Lusift.getActiveGuide();\n\n  if (activeGuide) {\n    bodyContent = Lusift.getContent()[activeGuide.id].data.steps[index].data.bodyContent || bodyContent;\n    footerContent = Lusift.getContent()[activeGuide.id].data.steps[index].data.footerContent || footerContent;\n  }\n\n  const tooltipInstance = await createTooltip({\n    target,\n    content,\n    arrow,\n    offset,\n    maxWidth,\n    placement,\n    remove: () => {},\n    onShow,\n    onHide,\n    onBeforeFirstRender: () => {\n      Lusift.render(bodyContent, \".lusift > .tooltip > .body-content\", () => {\n      });\n      // TODO: the second render call breaks Lusift on vue, commenting out for now\n      /* Lusift.render(footerContent, \".lusift > .tooltip > .footer\", () => {\n      }); */\n    },\n    scrollIntoView,\n    arrowSizeScale,\n    showOnCreate: true\n  });\n  // tooltipInstance.show(true)\n\n  return tooltipInstance;\n};\n\nexport default renderTooltip;\n","import { BACKDROP_Z_INDEX, OVERLAY_SELECTOR_CLASS } from '../common/constants';\nimport { document } from 'global';\nimport {\n  getElementPosition,\n  getDocumentDimensions\n} from \"../common/utils/\";\n\nconst div = () => document.createElement(\"div\");\n\nconst hexToRgbA = (hex: string, opacity: number) => {\n    let c: any;\n    if(/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)){\n        c= hex.substring(1).split('');\n        if(c.length== 3){\n            c= [c[0], c[0], c[1], c[1], c[2], c[2]];\n        }\n        c= '0x'+c.join('');\n        return 'rgba('+[(c>>16)&255, (c>>8)&255, c&255].join(',')+`,${opacity})`;\n    }\n    return `rgba(0, 0, 0, ${opacity})`;\n}\n\nconst createOverlay = ({ targetElement, stageGap, color, opacity }) => {\n  const overlay = div();\n  overlay.classList.add(OVERLAY_SELECTOR_CLASS);\n\n  const padding = stageGap;\n  const targetPosition = getElementPosition(targetElement);\n\n  Object.assign(overlay.style, {\n    position: 'absolute',\n    zIndex: BACKDROP_Z_INDEX,\n    left: `${targetPosition.left - padding/2}px`,\n    top: `${targetPosition.top - padding/2}px`,\n    width: `${targetPosition.width + padding}px`,\n    pointerEvents: 'none',\n    height: `${targetPosition.height + padding}px`,\n    boxShadow: `0 0 0 99999px ${hexToRgbA(color, opacity)}`,\n  });\n\n  const attachOverlay = () => document.documentElement.appendChild(overlay);\n  const detachOverlay = () => document.documentElement.removeChild(overlay);\n  const removeOverlay = () => overlay.remove();\n\n  return {\n    node: overlay,\n    removeOverlay,\n    detachOverlay,\n    attachOverlay,\n  }\n}\n\nexport default createOverlay;\n","import { document, window } from \"global\";\nimport {\n    getStepUID,\n    addFocusTrap,\n    copyObject,\n    hasFocussableElements\n} from \"../common/utils/\";\nimport { log, warn, error } from \"../common/logger\";\nimport { BackdropData } from \"../common/types\";\nimport createOverlayElement from './createOverlayElement';\n\nconst getElement = (elementSelector: string): Element => document.querySelector(elementSelector);\n\nclass Backdrop {\n    private targetSelector: string;\n    readonly stagedTargetClass: string;\n    private data: BackdropData;\n    private toStopOverlay: boolean = false;\n    private focusTrap: any;\n    public removeOverlay: () => void = () => {};\n\n    constructor({\n        targetSelector,\n        guideID,\n        index,\n        data,\n    }: {\n        targetSelector: string;\n        index: number;\n        guideID: string;\n        data: any;\n    }) {\n        const uid = getStepUID({ guideID, index, type: \"backdrop\" });\n        this.stagedTargetClass = `${uid}__target`;\n\n        this.data = copyObject(data);\n        this.targetSelector = targetSelector;\n\n        this.createOverlay();\n\n        const target = [\".lusift > .tooltip\", this.targetSelector];\n\n        const toEnableFocusTrap = hasFocussableElements(getElement(target[0])) ||\n            hasFocussableElements(getElement(target[1]));\n\n        // trap focus inside tooltip\n        if (toEnableFocusTrap) {\n            this.focusTrap = addFocusTrap({\n                target\n            });\n        }\n    }\n\n    public resetBackdrop(): void {\n        // HACK: intervene in the event backdrop has already been closed and there's a rogue timeout: rare\n        if (this.toStopOverlay) return error(`Lusift: This overlay instance should be removed`);\n        this.removeOverlay();\n        this.createOverlay();\n    }\n\n    private createOverlay(): void {\n        const targetElement = getElement(this.targetSelector);\n        const { color, opacity } = this.data;\n\n        const {\n            removeOverlay,\n            attachOverlay,\n        } = createOverlayElement({\n            targetElement,\n            stageGap: this.data.stageGap,\n            color,\n            opacity\n        });\n        attachOverlay();\n        this.removeOverlay = removeOverlay;\n    }\n\n    public remove(): void {\n        // log('removing Backdrop');\n        // remove event listeners\n        this.toStopOverlay = true;\n        if (this.focusTrap) {\n            this.focusTrap.deactivate();\n        }\n        this.removeOverlay();\n    }\n}\n\nexport default Backdrop;\n","import { document, window } from \"global\";\nimport createTooltip from \"./createTooltip\";\nimport { getStepUID, debounce, copyObject } from \"../common/utils\";\nimport { log, warn, error } from \"../common/logger\";\nimport { TooltipData, HotspotAndTooltipTarget as Target, StepActions } from \"../common/types\";\nimport Backdrop from \"../backdrop\";\nimport { autoUpdate } from '@floating-ui/dom';\n\n// TODO: should we have transition effects for backdrop? it's kind of jerky\n\nexport default class Tooltip {\n    private targetElement: HTMLElement;\n    readonly target: Target;\n    private fuitInstance: any;\n    readonly uid: string;\n    readonly data: TooltipData;\n    private actions: StepActions;\n    readonly styleProps: Object;\n    private targetsAndEventListeners: {\n        method: string;\n        target: HTMLElement;\n        eventType: string;\n    }[] = [];\n    private backdropInstance: any;\n    private index: number;\n    private guideID: string;\n    private isTooltipShown: boolean = false;\n    private backdropAutoUpdateCleanup!: Function;\n    private onRemove: Function;\n\n    constructor({\n        target,\n        guideID,\n        index,\n        data,\n        actions,\n        styleProps,\n        onRemove\n    }: {\n        target: Target;\n        guideID: string;\n        data: TooltipData;\n        index: number;\n        actions: StepActions;\n        styleProps: Object;\n        onRemove: Function\n    }) {\n        log(\"%c Tooltip constructor! \", \"background: #222; color: #bada55\");\n\n        this.target = target;\n        this.actions = copyObject(actions);\n        const { elementSelector } = target;\n        this.styleProps = copyObject(styleProps);\n        this.data = copyObject(data);\n        this.index = index;\n        this.onRemove = onRemove;\n\n        this.data.progressOn.elementSelector = this.data.progressOn.elementSelector || elementSelector;\n\n        if (!this.data.backdrop.disabled) {\n            // factor in backdrop stage gap in tooltip offset\n            this.data.offset[0] = this.data.offset[0] + this.data.backdrop.stageGap;\n        }\n\n        this.uid = getStepUID({ guideID, index, type: \"tooltip\" });\n        this.guideID = guideID;\n        this.targetElement = document.querySelector(elementSelector);\n        this.show();\n        // log(\"tooltip started\");\n    }\n\n    private hide(): void {\n        // log('tooltip hide');\n        this.fuitInstance.hide();\n        this.removeAllEventListeners();\n        this.backdropInstance && this.backdropInstance.remove();\n        this.backdropInstance = null;\n        this.isTooltipShown = false;\n    }\n\n    private addBackdrop(): void {\n        const { stageGap, opacity, color } = this.data.backdrop;\n        const data = {\n            stageGap,\n            opacity,\n            color,\n        };\n        this.backdropInstance = new Backdrop({\n            targetSelector: this.target.elementSelector,\n            guideID: this.guideID,\n            index: this.index,\n            data,\n        });\n        if (this.data.backdrop.nextOnOverlayClick) {\n            Array.from<HTMLElement>(\n                document.getElementsByClassName(this.backdropInstance.overlaySelectorClass),\n            ).forEach((target: HTMLElement) => {\n                this.addEventListenerToTarget(target, \"next\");\n            });\n        }\n    }\n\n    public async show() {\n        if (!this.targetElement) return error(\"Error: target element not found\");\n        if (this.isTooltipShown) return error(\"Tooltip is already displayed\");\n\n        const { progressOn, backdrop } = this.data;\n\n        const { eventType, disabled } = progressOn;\n        disabled || this.addEventListenerToTarget(this.targetElement, \"next\", eventType);\n\n        if (!this.fuitInstance) {\n            // fuit was never initiated\n            const { uid, actions, styleProps, data, index } = this;\n            this.fuitInstance = await createTooltip({\n                uid,\n                target: this.targetElement,\n                actions,\n                styleProps,\n                data,\n                scrollIntoView: true,\n                index,\n                onShow: (instance) => {\n                    if(instance.state.isShown) {\n                        backdrop.disabled || this.addBackdrop.bind(this)();\n                        this.isTooltipShown = true;\n                    } else {\n                        console.log('onShow: onShow ran but it\\'s hidden')\n                    }\n                },\n                onHide: (instance) => {\n                    if(!backdrop.disabled) {\n                        this.backdropInstance && this.backdropInstance.remove();\n                        this.backdropInstance = null;\n                        this.isTooltipShown = false;\n                    }\n                },\n            });\n            if (!backdrop.disabled) {\n\n                const debouncedBackdropReset = debounce((_x?) => {\n                    console.log('auto update triggered for backdrop. debounce method')\n                    if (this.backdropInstance) {\n                        this.backdropInstance.resetBackdrop();\n                    }\n                }, 100);\n\n                // NOTE: Brave browser has a bug where the dev-tools dock\n                // at certain sizes will trigger resize on loop\n                this.backdropAutoUpdateCleanup = autoUpdate(\n                    this.targetElement,\n                    this.fuitInstance.tooltipElement,\n                    () => {\n                        debouncedBackdropReset(undefined);\n                    },\n                    {\n                        ancestorScroll: false,\n                        ancestorResize: true,\n                        elementResize: true\n                    });\n            }\n        } else {\n            // fuit was hidden\n            this.fuitInstance.show();\n        }\n    }\n\n    public remove(): void {\n        if (!this.isTooltipShown) return error(`Attempted to remove but tooltip is not shown`);\n        log(`removing tooltip ${this.uid}`);\n        this.removeAllEventListeners();\n        this.backdropInstance && this.backdropInstance.remove();\n        this.fuitInstance.remove();\n        this.fuitInstance = null;\n        this.isTooltipShown = false;\n        this.onRemove();\n    }\n\n    private getListenerFromMethod(method: string): EventListenerOrEventListenerObject {\n        switch (method) {\n            case \"next\":\n                return window.Lusift.next;\n            case \"prev\":\n                return window.Lusift.prev;\n            case \"close\":\n                return this.remove;\n            default:\n                return () => {};\n        }\n    }\n\n    private addEventListenerToTarget(\n        target: HTMLElement,\n        method = \"next\",\n        eventType = \"click\",\n    ): void {\n        // add this event listener at the creation of each tooltip step and\n        // remove it at removal of it\n        target.addEventListener(eventType, this.getListenerFromMethod(method));\n        this.targetsAndEventListeners.push({\n            method,\n            target,\n            eventType,\n        });\n    }\n\n    private removeAllEventListeners(): void {\n        this.backdropAutoUpdateCleanup && this.backdropAutoUpdateCleanup();\n        this.targetsAndEventListeners.forEach(({ method, target, eventType }) => {\n            target.removeEventListener(eventType, this.getListenerFromMethod(method));\n            log(`remove event listener of type ${eventType} ` + `and method ${method}`);\n        });\n        this.targetsAndEventListeners = [];\n    }\n}\n","import { document } from \"global\";\nimport { MODAL_OVERLAY_CLASS, MODAL_CLASS, DEFAULT_MODAL_BORDER_RADIUS, MODAL_OVERLAY_Z_INDEX } from \"../common/constants\";\nimport { styleObjectToString } from \"../common/utils\";\nimport renderProgressBar from \"../common/progressBar\";\nimport renderCloseXButton from \"../common/closeXButton\";\n\nconst defaultBodyContent = `\n  <style>\n  .lusift .modal h2 {\n    font-weight: bold;\n    font-size: 1.5rem;\n    text-align: center;\n    margin-bottom: 0.5rem;\n  }\n  .lusift .modal p {\n    text-align: center;\n  }\n  .lusift .modal .button-area {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    margin: 1rem 0;\n  }\n\n  .lusift .modal .button-area button {\n    font-size: 1.1rem;\n    padding: 0.45rem 0.75rem;\n  }\n  </style>\n  <div class=\"modal\">\n    <h2>Default Modal Content</h2>\n    <p>This is the default modal content!</p>\n    <div class=\"button-area\">\n      <button class=\"button\" onclick=\"Lusift.next()\">\n        Next\n      </button>\n    </div>\n  </div>\n`;\n\nconst div = () => document.createElement(\"div\");\n\nexport const noScrollBody = () => {\n  document.body.classList.add(\"lusift-no-scroll\");\n};\n\nexport const restoreScrollBody = () => {\n  document.body.classList.remove(\"lusift-no-scroll\");\n};\n\nconst createModal = ({ uid, index, closeButton, progressBar, styleProps, overlay }): () => void => {\n\n  const modalOverlay = div();\n  const modal = div();\n  const lusiftWrapper = div();\n  modalOverlay.classList.add(MODAL_OVERLAY_CLASS);\n  modal.id = uid;\n  modal.classList.add(MODAL_CLASS);\n  lusiftWrapper.classList.add(\"lusift\");\n  modal.innerHTML = `\n    <style>\n      .lusift-progress {\n        ${styleObjectToString({\n          ...progressBar.styleProps,\n          backgroundColor: undefined\n        })}\n      }\n      .lusift-progress::-webkit-progress-bar {\n        ${styleObjectToString({\n          ...progressBar.styleProps,\n          backgroundColor: undefined\n        })}\n      }\n      .lusift-progress::-webkit-progress-value {\n        ${styleObjectToString(progressBar.styleProps)}\n      }\n\n      .lusift-progress::-moz-progress-bar {\n        initial: none;\n        ${styleObjectToString({\n          ...progressBar.styleProps,\n          backgroundColor: undefined\n        })}\n      }\n    </style>\n    ${renderCloseXButton(closeButton, \"modal\")}\n    <section class=\"body-content\">\n    </section>\n  `;\n\n  if (!progressBar.disabled) {\n    modal.prepend(renderProgressBar());\n  }\n\n  Object.assign(modalOverlay.style, {\n    position: 'fixed',\n    overflowY: \"scroll\",\n    background: \"rgba(40,40,40, .5)\",\n    top: \"0\",\n    left: \"0\",\n    bottom: \"0\",\n    right: \"0\",\n    zIndex: MODAL_OVERLAY_Z_INDEX,\n    ...overlay.styleProps\n  });\n\n  Object.assign(modal.style, {\n    margin: '15vh auto',\n    width: '80%',\n    maxWidth: '650px',\n    background: 'rgba(255,255,255, 1)',\n    position: 'relative',\n    borderRadius: DEFAULT_MODAL_BORDER_RADIUS,\n    ...styleProps\n  });\n\n  lusiftWrapper.appendChild(modal);\n  modalOverlay.appendChild(lusiftWrapper);\n  document.body.appendChild(modalOverlay);\n\n  const Lusift = window[\"Lusift\"];\n\n  let bodyContent = defaultBodyContent;\n  const activeGuide = Lusift.getActiveGuide();\n\n  if (activeGuide) {\n    bodyContent = Lusift.getContent()[activeGuide.id].data.steps[index].data.bodyContent || bodyContent;\n  }\n\n  Lusift.render(bodyContent, \".lusift > .modal > .body-content\");\n  noScrollBody();\n\n  return function destroyModal() {\n    document.body.removeChild(modalOverlay);\n    restoreScrollBody();\n  };\n};\n\nexport default createModal;\n","import createModal, { noScrollBody, restoreScrollBody } from \"./createModal\";\nimport { document, window } from \"global\";\nimport { getStepUID, addFocusTrap, copyObject } from \"../common/utils\";\nimport { ModalData } from \"../common/types\";\nimport { MODAL_OVERLAY_CLASS, MODAL_CLASS } from \"../common/constants\";\n\nclass Modal {\n    private data: ModalData;\n    private focusTrap: any;\n    private onRemove: Function;\n    private removeModal: Function;\n\n    constructor({ index, guideID, data, closeButton, onRemove, overlay, styleProps }) {\n        const uid = getStepUID({ guideID, type: \"modal\", index });\n        this.data = copyObject(data);\n        index = index;\n\n        this.removeModal = createModal({\n            uid,\n            index,\n            closeButton,\n            styleProps,\n            overlay,\n            progressBar: data.progressBar\n        });\n\n        const { escToClose, clickOutsideToClose } = this.data;\n\n        const isDevMode = !window.Lusift.getActiveGuide();\n\n        this.focusTrap = addFocusTrap({\n            target: \".modal\",\n            escapeDeactivates: (e): boolean => {\n                if (!isDevMode && escToClose) {\n                    window['Lusift'].next();\n                    return true;\n                }\n                return false;\n            },\n            clickOutsideDeactivates: (e): boolean => {\n                if (\n                    !isDevMode &&\n                    clickOutsideToClose &&\n                    !e.target.classList.contains(MODAL_CLASS) &&\n                    e.target.classList.contains(MODAL_OVERLAY_CLASS) &&\n                    !e.target.closest(`.${MODAL_CLASS}`)\n                ) {\n                    window['Lusift'].next();\n                    return true;\n                }\n                return false;\n            },\n        });\n\n        this.onRemove = onRemove;\n    }\n\n    private remove(): void {\n        this.focusTrap.deactivate();\n        this.removeModal();\n        this.onRemove();\n    }\n}\n\nexport default Modal;\n","import createTooltip from \"../common/createTooltip\";\nimport renderProgressBar from \"../common/progressBar\";\nimport { DEFAULT_TOOLTIP_BORDER_RADIUS } from \"../common/constants\";\n\nconst defaultBodyContent = `\n  <h3 style=\"font-weight: bold;\">Default title</h3>\n  <p style=\"font-weight: normal;\">Default hotspot tip content</p>\n`;\n\nconst div = () => document.createElement(\"div\");\n\nconst renderTooltip = async ({ remove, data, target, styleProps, uid, index, onClickOutside, showOnCreate }) => {\n  const {\n    arrow,\n    placement,\n    offset,\n    maxWidth,\n    // bodyContent = defaultBodyContent,\n  } = data;\n\n  const content = div();\n  content.className = 'lusift';\n\n  content.setAttribute('aria-label', 'tooltip');\n  content.innerHTML = `\n    <div class=\"hotspot-tooltip\" id=\"tooltip-${uid}\">\n    <section class=\"body-content\">\n    </section>\n    </div>\n  `;\n  content.prepend(renderProgressBar());\n  Object.assign(content.style, {\n    borderRadius: DEFAULT_TOOLTIP_BORDER_RADIUS,\n    ...styleProps,\n  });\n\n  const tooltipInstance = await createTooltip({\n    target,\n    content,\n    arrow,\n    offset,\n    maxWidth,\n    placement,\n    onClickOutside,\n    hideOnReferenceHidden: false,\n    hideOnTooltipEscape: false,\n    showOnCreate,\n    remove: () => {},\n  });\n\n  const Lusift = window[\"Lusift\"];\n\n  let bodyContent = defaultBodyContent;\n  const activeGuide = Lusift.getActiveGuide();\n\n  if (activeGuide) {\n    // TODO: Why did we decide to pull from Lusift.getContent() and not from this function's parameter again?\n    bodyContent = Lusift.getContent()[activeGuide.id].data.steps[index].tip.data.bodyContent || bodyContent;\n  }\n\n  Lusift.render(bodyContent, `.lusift > .hotspot-tooltip#tooltip-${uid} > .body-content`, () => {\n    tooltipInstance.update();\n  });\n\n  return tooltipInstance;\n};\n\nexport default renderTooltip;\n","import { document, window } from \"global\";\nimport { styleObjectToString, getElementPosition } from \"../common/utils\";\nimport { BEACON_CONTAINER_CLASS, BEACON_Z_INDEX } from \"../common/constants\";\n\nconst appendTo = () => document.body;\n\nexport function div(): HTMLDivElement {\n  return document.createElement('div');\n}\n\nexport const positionBeacon = (\n  beaconElement: HTMLDivElement,\n  targetPosition,\n  beaconPlacement: { top: number; left: number; }\n) => {\n    const { targetTop, targetLeft, targetHeight, targetWidth } = targetPosition;\n\n    const { top, left } = beaconPlacement;\n\n    const beaconID = beaconElement.getAttribute('id');\n    const beaconContainer = beaconElement.parentElement!;\n    const beaconEventReceiver = <HTMLElement>beaconElement.querySelector(`#${beaconID}-er`)!;\n\n    Object.assign(beaconContainer.style, {\n      top: `${targetTop}px`,\n      left: `${targetLeft}px`,\n    });\n\n    const { width, height } = getElementPosition(<HTMLElement>beaconElement);\n\n    Object.assign(beaconEventReceiver.style, {\n        width: `${width}px`,\n        height: `${height}px`,\n    });\n\n    Object.assign(beaconElement.style, {\n        top: `${(top / 100) * targetHeight}px`,\n        left: `${(left / 100) * targetWidth}px`\n    });\n}\n\nexport const createBeaconElement = ({ beaconData, beaconID, toggleTooltip }) => {\n\n    const beaconContainer = div();\n    beaconContainer.classList.add(BEACON_CONTAINER_CLASS);\n    Object.assign(beaconContainer.style, {\n        position: \"absolute\",\n    });\n\n    let { size, color, type } = beaconData;\n    const animation = true;\n\n    beaconContainer.innerHTML = `\n    <style>\n      #${beaconID} {\n        background-color: ${color || \"#b9f\"};\n        border-radius: 50%;\n        position: absolute;\n        pointer-events: auto;\n        width: ${size * 13}px;\n        height: ${size * 13}px;\n\n        ${\n            animation\n                ? `\n        -webkit-animation: shine 2s ease-in-out infinite;\n        animation: shine 2s ease-in-out infinite;\n          `\n                : \"\"\n        }\n        cursor: pointer;\n        -webkit-animation-delay: 1s;\n        animation-delay: 1s;\n      }\n\n\n      @-webkit-keyframes shine {\n        0%, 20% {\n          box-shadow: 0px 0px 0px 0px rgba(187, 153, 255, 0.49);\n        }\n        100% {\n          box-shadow: 0px 0px 0px ${20 * size}px rgba(0, 0, 0, 0);\n        }\n      }\n\n      @keyframes shine {\n        0%, 20% {\n          box-shadow: 0px 0px 0px 0px rgba(187, 153, 255, 0.49);\n        }\n        100% {\n          box-shadow: 0px 0px 0px ${20 * size}px rgba(0, 0, 0, 0);\n        }\n      }\n    }\n    </style>\n    <div class=\"lusift-beacon\" id=\"${beaconID}\"></div>\n  `;\n\n\n    appendTo().appendChild(beaconContainer);\n    const beaconElement = <HTMLElement>beaconContainer.querySelector(`#${beaconID}`)!;\n\n    const beaconEventReceiver = div();\n    beaconEventReceiver.id = `${beaconID}-er`;\n\n    Object.assign(beaconEventReceiver.style, {\n        ...beaconElement!.style,\n        background: \"transparent\",\n        zIndex: BEACON_Z_INDEX,\n    });\n\n    beaconElement.appendChild(beaconEventReceiver);\n\n    beaconEventReceiver.addEventListener(\"click\", toggleTooltip);\n    return beaconEventReceiver;\n}\n","import { document, window } from \"global\";\nimport createHotspotTooltip from \"./createHotspotTooltip\";\nimport { createBeaconElement, positionBeacon } from \"./beacon-element\";\nimport { autoUpdate } from '@floating-ui/dom';\nimport {\n    getElementPosition,\n    getStepUID,\n    changeAsyncStepStatus,\n    debounce,\n    copyObject\n} from \"../common/utils\";\nimport { Hotspot as HotspotData } from \"../common/types\";\nimport { log, warn, error } from \"../common/logger\";\n\n// TODO_: In case of customizing hotspot's beacon, we can just have a beaconElement property\n// TODO: Should the beacon animation stop when tip is open?\n\nclass Hotspot {\n    private tipID: string;\n    private fuitInstance: any;\n    private targetElement: HTMLElement;\n    readonly data: HotspotData;\n    private beaconID: string;\n    private beaconAutoUpdateCleanup!: Function;\n    private onRemove: Function;\n\n    constructor({ data, guideID, onRemove }) {\n        log(data);\n        this.data = copyObject(data);\n        this.onRemove = onRemove;\n        const { index, type, target } = this.data;\n        this.tipID = getStepUID({ guideID, type, index });\n        this.beaconID = getStepUID({\n            guideID,\n            type: \"beacon\",\n            index,\n        });\n        this.targetElement = document.querySelector(target.elementSelector);\n        this.addBeacon();\n        this.createTip();\n    }\n\n    private updateBeaconPosition() : void {\n        let {\n            top: targetTop,\n            left: targetLeft,\n            width: targetWidth,\n            height: targetHeight,\n        } = getElementPosition(this.targetElement);\n        const targetPosition = {\n            targetTop,\n            targetLeft,\n            targetWidth,\n            targetHeight,\n        };\n        const beaconData = this.data.beacon;\n\n        const beaconElement = document.getElementById(this.beaconID);\n        positionBeacon(beaconElement, targetPosition, beaconData.placement);\n    }\n\n    private addBeacon(): void {\n        log(\"adding beacon\");\n\n        const beaconData = this.data.beacon;\n\n        createBeaconElement({\n            beaconData,\n            beaconID: this.beaconID,\n            toggleTooltip: this.toggleTooltip.bind(this),\n        });\n        this.updateBeaconPosition();\n    }\n\n    private async createTip() {\n        const Lusift = window[\"Lusift\"];\n        const target = document.getElementById(`${this.beaconID}`);\n        const { data, styleProps } = this.data.tip;\n        const isDevMode = !Boolean(Lusift.getActiveGuide());\n\n        // do not allow async step to close in dev mode\n        const removeMethod = isDevMode ? Lusift.close : this.removeAndCloseAsync.bind(this);\n\n        this.fuitInstance = await createHotspotTooltip({\n            remove: removeMethod,\n            uid: this.tipID,\n            index: this.data.index,\n            target: target,\n            styleProps,\n            showOnCreate: false,\n            data,\n            onClickOutside: (instance, event) => {\n                removeMethod();\n            }\n        });\n\n        // reposition beacon on body and targetElement resize\n\n        const updateBeaconPosition = this.updateBeaconPosition.bind(this);\n\n        const debouncedUpdateBeaconPosition = debounce((_x?) => {\n            updateBeaconPosition();\n            this.fuitInstance.update();\n        }, 100);\n\n        this.beaconAutoUpdateCleanup = autoUpdate(\n            this.targetElement,\n            this.fuitInstance.tooltipElement,\n            () => {\n                debouncedUpdateBeaconPosition(undefined);\n            },\n            {\n                ancestorScroll: false,\n                ancestorResize: true,\n                elementResize: true\n            });\n    }\n\n    private async toggleTooltip() {\n        // log('toggle tooltip');\n\n        const activeHotspot = window.Lusift.activeHotspot;\n        const Lusift = window[\"Lusift\"];\n\n        if (activeHotspot && this.data.index !== activeHotspot.data.index) {\n            // hide any other potentially active hotspot tip\n            Lusift.activeHotspot.hideTooltip();\n        }\n\n        if (this.fuitInstance.getState().isRemoved) {\n            error(\"Uh... but it doesn't exist. unexpected\");\n            // if it's removed\n        } else if (this.fuitInstance.getState().isShown) {\n            await this.hideTooltip();\n        } else if (this.fuitInstance) {\n            // if it's hidden\n            await this.fuitInstance.show();\n            Lusift.activeHotspot = this;\n        }\n    }\n\n    // TODO: refactor names, here it could be hideTip()\n    public async hideTooltip() {\n        await this.fuitInstance.hide();\n        window.Lusift.activeHotspot = null;\n    }\n\n    private changeAsyncStepStatus(toOpen: boolean): void {\n        if (!this.data.async) return;\n        changeAsyncStepStatus(this.data.index, toOpen);\n    }\n\n    private async remove() {\n        log(`Removing id: ${this.data.index} hotspot`);\n\n        if (this.fuitInstance) {\n            if (this.fuitInstance.getState().isShown) {\n                await this.hideTooltip();\n            }\n            if (this.fuitInstance.getState().isRemoved) {\n                log(\"Hotspot's tooltip is already destroyed\");\n            } else {\n                this.fuitInstance.remove();\n            }\n        } else {\n            log(\"Hotspot closed without ever opening\");\n        }\n        const beaconElement = document.getElementById(this.beaconID);\n        if (beaconElement) {\n            beaconElement.parentElement.remove();\n        }\n    }\n\n    private removeResizeObservers(): void {\n        this.beaconAutoUpdateCleanup();\n    }\n\n    private removeAndCloseAsync(): void {\n        this.remove();\n        this.changeAsyncStepStatus(false);\n        this.removeResizeObservers();\n        this.onRemove();\n    }\n}\n\nexport default Hotspot;\n","import Tooltip from \"../tooltip\";\nimport Modal from \"../modal\";\nimport Hotspot from \"../hotspot\";\n\nconst startStepInstance = (stepData: any, guideID: string, onRemove: Function): void => {\n    const { index, target, type, data, closeButton, styleProps, overlay } = stepData;\n    let activeStepInstance: any;\n\n    if (type === \"tooltip\") {\n        const { actions, styleProps } = stepData;\n        activeStepInstance = new Tooltip({\n            target,\n            data,\n            index,\n            guideID,\n            actions,\n            styleProps,\n            onRemove\n        });\n    } else if (type === \"modal\") {\n        activeStepInstance = new Modal({\n            index,\n            guideID,\n            data,\n            closeButton,\n            onRemove,\n            overlay,\n            styleProps,\n        });\n    } else if (type === \"hotspot\") {\n        activeStepInstance = new Hotspot({\n            data: stepData,\n            guideID,\n            onRemove\n        });\n    }\n    return activeStepInstance;\n};\n\nexport default startStepInstance;\n","import { window } from \"global\";\nimport { saveState, loadState } from \"../common/store\";\nimport { log, warn, error } from \"../common/logger\";\nimport {\n    changeAsyncStepStatus,\n    doesStepMatchDisplayCriteria,\n} from \"../common/utils\";\n\nimport startStepInstance from './startStepInstance';\n\nimport { GuideType, ActiveStep, TrackingState, StepTargetType } from \"../common/types\";\n\n// TODO: refactor this\n// TODO: Add property `closeOnLastNext`\n//\n\nexport default class Guide {\n    readonly guideData: GuideType;\n    private activeSteps: ActiveStep[] = [];\n\n    constructor(guideID: string) {\n        // localGuideState consists of trackingState and guideData\n        log(\"guide constructor\");\n        log(loadState());\n        const localGuideState = window['Lusift'].getContent()[guideID].data;\n        const guideData = Object.assign({}, localGuideState);\n\n        this.guideData = guideData;\n        log(\n            `%c Welcome to guide: ${this.guideData.name || this.guideData.id}`,\n            \"background: #222; color: #bada55\",\n        );\n        const trackingState = loadState()[guideID]?.trackingState;\n\n        if (!trackingState) {\n            this.resetTrackingState();\n        }\n    }\n\n    public getActiveSteps(): ActiveStep[] {\n        return this.activeSteps;\n    }\n\n    private generateNewTrackingState(): TrackingState {\n        let newTrackingState = {\n            currentStepIndex: 0,\n            finished: false,\n            prematurelyClosed: false,\n            asyncSteps: {},\n            enabled: false,\n        };\n\n        //for async steps\n        this.guideData.steps.forEach(step => {\n            if (\"async\" in step) {\n                if (step.async && step.type === \"hotspot\") {\n                    newTrackingState.asyncSteps[step.index] = {\n                        toOpen: false,\n                    };\n                }\n            }\n        });\n        return newTrackingState;\n    }\n\n    public start(): void {\n        const { finished, prematurelyClosed } = this.getTrackingState();\n        this.removeIllegalSteps();\n        this.attemptToStartAsyncSteps();\n\n        // TODO: Add a case for when steps.length is 0\n        if (finished || prematurelyClosed) {\n            error(\"Guide is already finished or closed\");\n        } else {\n            this.attemptToShowActiveStep();\n        }\n    }\n\n    public removeAllActiveSteps(): void {\n        this.activeSteps.forEach(stepInstance => {\n            // instance.reRenderPageElements();\n            const { type, target, instance, async } = stepInstance;\n            if (async && type === \"hotspot\") {\n                instance.removeResizeObservers();\n            }\n            instance.remove();\n        });\n        this.activeSteps = [];\n    }\n\n    public reRenderStepElements(): void {\n        log(\"re-render step elements\");\n        this.removeAllActiveSteps();\n        this.start();\n    }\n\n    private attemptToShowActiveStep(): void {\n        // we start with some currentStep from this.trackingState\n        // if the step is async, set toOpen to true\n        // -- if display criteria matches and step isn't already displayed, then startStep\n        // if the step is async, loop back with stepIndex++\n        const { currentStepIndex } = this.getTrackingState();\n        let stepIndex = currentStepIndex;\n        const { steps } = this.guideData;\n        let isAsyncStep: boolean;\n\n        stepIndex--;\n        do {\n            stepIndex++;\n            const step = steps[stepIndex];\n            const { target, type } = steps[stepIndex];\n            let async = false;\n            if (\"async\" in step) {\n                async = step.async!;\n            }\n            const displayCriteriaMatches = doesStepMatchDisplayCriteria({\n                target,\n                type,\n            });\n            isAsyncStep = async && type === \"hotspot\";\n\n            if (isAsyncStep) {\n                changeAsyncStepStatus(stepIndex, true);\n            }\n            if (displayCriteriaMatches && !this.isStepActive(stepIndex)) {\n                this.activeSteps.push({\n                    index: stepIndex,\n                    instance: startStepInstance(\n                        steps[stepIndex],\n                        this.guideData.id,\n                        () => {\n                            this.activeSteps = this.activeSteps.filter(step => {\n                                return step.index !== stepIndex;\n                            });\n                        }\n                    ),\n                    target,\n                    type,\n                    async,\n                });\n            }\n        } while (isAsyncStep);\n\n        let newTrackingState = this.getTrackingState();\n        newTrackingState.currentStepIndex = stepIndex;\n        this.setTrackingState(newTrackingState);\n    }\n\n    private isStepActive(stepIndex: number): boolean {\n        return this.activeSteps.some(({ index }) => index === stepIndex);\n    }\n\n    public getProgress(): number {\n        // filter out steps that are not of type hotspot with async property of true\n        const syncSteps = this.guideData.steps.filter(step => {\n            return !(step.type === \"hotspot\" && step['async']);\n        });\n        const currentStep = this.guideData.steps[this.getTrackingState().currentStepIndex];\n\n        const progress =\n            ((syncSteps.findIndex(step => {\n                return step.index === currentStep.index;\n            }) +\n                1) /\n                (syncSteps.length + 1)) *\n            100;\n        return progress;\n    }\n\n    private attemptToStartAsyncSteps(): void {\n        // start all the async hotpots with toOpen true\n        const steps = this.guideData.steps;\n        steps.forEach(step => {\n            const { type, index, target } = step;\n            let async = false;\n            if (\"async\" in step) {\n                async = step.async!;\n            }\n            if (async && type === \"hotspot\") {\n                if (\n                    doesStepMatchDisplayCriteria({ target, type }) &&\n                    this.getTrackingState().asyncSteps[index].toOpen\n                ) {\n                    log(`Step ${index}: target path and element matched. toOpen is true`);\n                    // if step is already active warn that the step is already active\n                    if (this.isStepActive(index)) {\n                        return warn(`Step ${index} is already active`);\n                    }\n                    this.activeSteps.push({\n                        index,\n                        instance: startStepInstance(\n                            steps[index],\n                            this.guideData.id,\n                            () => {\n                                this.activeSteps = this.activeSteps.filter(step => {\n                                    return step.index !== index;\n                                });\n                            }\n                        ),\n                        target,\n                        type,\n                        async,\n                    });\n                }\n            }\n        });\n    }\n\n    private removeIllegalSteps(): void {\n        this.activeSteps = this.activeSteps.filter(stepInstance => {\n            // if step display criteria doesn't match, then run remove() and remove from this.activeSteps\n            const { type, target, instance, async } = stepInstance;\n            if (!doesStepMatchDisplayCriteria({ target, type })) {\n                if (async && type === \"hotspot\") {\n                    instance.removeResizeObservers();\n                }\n                instance.remove();\n                return false;\n            } else {\n                return true;\n            }\n        });\n    }\n\n    private setTrackingState(trackingState: TrackingState): void {\n        const existingState = loadState();\n        saveState({\n            ...existingState,\n            [this.guideData.id]: {\n                ...existingState[this.guideData.id],\n                trackingState,\n            },\n        });\n    }\n\n    public getTrackingState(): TrackingState {\n        return loadState()[this.guideData.id].trackingState;\n    }\n\n    private resetTrackingState(): void {\n        const newTrackingState = this.generateNewTrackingState();\n        this.setTrackingState(newTrackingState);\n    }\n\n    public setStep(newStepNum: number): void {\n        // change step and see which steps need to be unmounted or mounted\n        let newTrackingState = this.getTrackingState();\n        if (newStepNum < 0) {\n            return error(\"Step index can't be less than 0\");\n        } else if (newStepNum + 1 > this.guideData.steps.length) {\n            if (!newTrackingState.finished) {\n                this.closeCurrentStep();\n                newTrackingState.finished = true;\n                this.setTrackingState(newTrackingState);\n            }\n            log(\"Guide finished\");\n        } else {\n            this.closeCurrentStep();\n            newTrackingState.currentStepIndex = newStepNum;\n            this.setTrackingState(newTrackingState);\n            this.start();\n        }\n    }\n\n    public remove(): void {\n        // remove guide\n        // if current step is last step then finished=true, else prematurelyClosed=true\n        let newTrackingState = this.getTrackingState();\n        if (newTrackingState.currentStepIndex + 1 === this.guideData.steps.length) {\n            newTrackingState.finished = true;\n        } else {\n            newTrackingState.prematurelyClosed = true;\n        }\n        this.setTrackingState(newTrackingState);\n        this.removeAllActiveSteps();\n        log(\"guide closed\");\n    }\n\n    private closeCurrentStep(): void {\n        // if this.trackingState.activeStep is equal to any index of item from this.activeSteps, then log('hello')\n        const { currentStepIndex } = this.getTrackingState();\n        const currentStep = this.activeSteps.find(({ index }) => index === currentStepIndex);\n\n        if (currentStep) {\n            currentStep.instance.remove();\n            this.activeSteps = this.activeSteps.filter(\n                instance => instance.index !== currentStepIndex,\n            );\n        } else {\n            warn(\"There's no active step to close\");\n        }\n    }\n\n    public nextStep(): void {\n        const newStep = this.getTrackingState().currentStepIndex + 1;\n        if (newStep + 1 > this.guideData.steps.length) {\n            if (!this.guideData.closeOnLastNext) {\n                return error(\"No new steps\");\n            }\n        }\n        this.closeCurrentStep();\n        this.setStep(newStep);\n        window.Lusift.onNext();\n    }\n\n    public prevStep(): void {\n        // make newStep the index of the closest previus step with !step.async\n        let newStep = this.getTrackingState().currentStepIndex;\n\n        while (newStep > -2) {\n            newStep--;\n            const step = this.guideData.steps[newStep];\n            if (!step) {\n                break;\n            }\n            let async = false;\n            if (\"async\" in step) {\n                async = step.async!;\n            }\n            let stepIsAsync = step.type === \"hotspot\" && async;\n            if (!stepIsAsync) {\n                break;\n            }\n        }\n        if (newStep < 0) return error(\"No previous steps\");\n        this.closeCurrentStep();\n        this.setStep(newStep);\n        const Lusift = window[\"Lusift\"];\n        Lusift.onPrev();\n    }\n}\n","import { Content, DeepPartial } from '../common/types';\nimport { ContentDefaults } from './types';\nimport { mergeDeep } from '../common/utils';\nimport { isObject } from '../common/utils/isOfType';\n\nconst defaultTooltipActions = {\n  styleProps: {},\n  closeButton: {\n    styleProps: {},\n    disabled: false,\n  },\n  navSection: {\n    disabled: false,\n    styleProps: {},\n    nextButton: {\n      text: 'next',\n      styleProps: {\n      },\n      disabled: false,\n    },\n    prevButton: {\n      text: 'prev',\n      styleProps: {},\n      disabled: false,\n    },\n    dismissLink: {\n      text: 'skip this',\n      styleProps: {},\n      disabled: false,\n    }\n  },\n}\n\nconst defaultTooltipBackdrop = {\n  disabled: false,\n  color: '#444',\n  opacity: '0.5',\n  stageGap: 5,\n  nextOnOverlayClick: false\n}\n\nconst defaultTooltipOffset = [0, 0];\n\nconst defaultTooltip = {\n  target: {\n    path: {\n      comparator: 'is'\n    },\n  },\n  data: {\n    placement: {\n      position: 'bottom',\n      orientation: 'auto'\n    },\n    arrow: true,\n    arrowSizeScale: 1,\n    backdrop: defaultTooltipBackdrop,\n    progressBar: {\n      disabled: false,\n      styleProps: {},\n    },\n    progressOn: {\n      eventType: 'click',\n    },\n    offset: defaultTooltipOffset,\n    maxWidth: 400\n  },\n  actions: defaultTooltipActions,\n  styleProps: {}\n}\n\nconst defaultHotspot = {\n  target: {\n    path: {\n      comparator: 'is'\n    },\n  },\n  beacon: {\n    placement: {\n      top: 90,\n      left: 90,\n    },\n    size: 1,\n    color: '', //what's this?\n    type: 'pulsing'\n  },\n  tip: {\n    data: {\n      placement: 'bottom',\n      arrow: true,\n      maxWidth: 400\n    },\n    styleProps: {\n    }\n  },\n  async: true\n}\n\nconst defaultModal = {\n  target: {\n    path: {\n      comparator: 'is'\n    }\n  },\n  closeButton: {\n    styleProps: {},\n    disabled: false,\n  },\n  data: {\n    escToClose: false,\n    clickOutsideToClose: false,\n    progressBar: {\n      disabled: false,\n      styleProps: {},\n    },\n  },\n  overlay: {\n    styleProps: {},\n  },\n  styleProps: {}\n}\n\nconst defaultGuideData = {\n  name: '',\n  description: '',\n  steps: [],\n  onNext: () => {},\n  onPrev: () => {},\n  onClose: () => {}\n}\n\nfunction removeUndefinedFieldsFromContent(obj) {\n  for (var key in obj) {\n    if (obj[key] === undefined) {\n      delete obj[key];\n      continue;\n    }\n    if (obj[key] && typeof obj[key] === \"object\" && !(obj[key] instanceof Element)) {\n      removeUndefinedFieldsFromContent(obj[key]);\n    }\n  }\n  return obj;\n}\n\nlet defaults = {\n  tooltip: defaultTooltip,\n  hotspot: defaultHotspot,\n  modal: defaultModal,\n}\n\nfunction overrideProps(target, source) {\n  let output = Object.assign({}, target);\n  if (isObject(target) && isObject(source)) {\n    Object.keys(source).forEach(key => {\n      if (isObject(source[key])) {\n        if ((key in target))\n          output[key] = mergeDeep(target[key], source[key]);\n      } else {\n        Object.assign(output, { [key]: source[key] });\n      }\n    });\n  }\n  return output;\n}\n\nexport default function combineContentWithDefaults(content: any, contentDefaults?: DeepPartial<ContentDefaults>): Content {\n  content = removeUndefinedFieldsFromContent(content);\n\n  if (contentDefaults) {\n    // combine input defaults with defaults, but only for properties that exist on defaults\n    defaults = overrideProps(defaults, contentDefaults);\n  }\n\n  Object.keys(content).forEach((guideID) => {\n    const guideData = content[guideID].data;\n\n    let completedGuideData = mergeDeep(defaultGuideData, guideData);\n    let steps = completedGuideData.steps;\n    steps = steps.map((step, index) => {\n      let completedStep = step;\n      if (step.type === 'tooltip') {\n        completedStep = mergeDeep(defaults.tooltip, step);\n      } else if (step.type === 'hotspot') {\n        completedStep = mergeDeep(defaults.hotspot, step);\n      } else if (step.type === 'modal') {\n        completedStep = mergeDeep(defaults.modal, step);\n      }\n      return completedStep;\n    });\n    completedGuideData.steps = steps;\n    content[guideID].data = completedGuideData;\n  });\n  return content;\n}\n","import Guide from \"./Guide\";\nimport { saveState, loadState, setDefaultState } from \"../common/store\";\nimport { log, error, warn } from \"../common/logger\";\nimport { doesStepMatchDisplayCriteria } from \"../common/utils\";\nimport startStepInstance from './startStepInstance';\nimport mergeContentWithDefaults from './defaults';\n\nimport { window, document } from \"global\";\n\nimport { Content, LocalState, ActiveGuide, DeepPartial } from \"../common/types\";\nimport { ContentDefaults, InputContent } from './types';\n\nimport { isOfTypeContent, isObject } from \"../common/utils/isOfType\";\n\nimport addDefaultCSS from \"./addDefaultCSS\";\n\n// NOTE: Stop refactoring\n// TODO: Add support for react 18\n\n// TODO_: add support for angul*r\n\nconst noOp = () => {}; // no-op function\n\nconst devNavMethod = () => {\n    error(`Can't run this method in dev mode`);\n}\n\nclass Lusift {\n    private content: Content = {};\n    public render: (body: any, targetPath: string, callback?: Function) => void = noOp;\n    private activeGuide: ActiveGuide | null = null;\n    private isDevMode: boolean = false;\n    private navigationMethods = {\n        next: noOp,\n        prev: noOp,\n        close: noOp,\n        goto: (x: number) => {},\n    }\n\n    constructor() {\n        log(\"%c Lusift constructor! \", \"background: #222; color: #bada55\");\n\n        const localData = loadState();\n        // set default state\n        if (!isObject(localData)) {\n            setDefaultState();\n        }\n        addDefaultCSS(); // this line adds css to the header\n    }\n\n    public next(): void {\n        return this.navigationMethods.next();\n    }\n\n    public prev(): void {\n        return this.navigationMethods.prev();\n    }\n\n    public goto(newStepNum: number): void {\n        return this.navigationMethods.goto(newStepNum);\n    }\n\n    public close(): void {\n        this.navigationMethods.close();\n    }\n\n    private showEnabledContent(): void {\n        const localData = loadState();\n        const enabledGuideID = Object.keys(localData).find(key => {\n            const { trackingState } = localData[key];\n            if(trackingState){\n                return trackingState.enabled;\n            }\n            return false;\n        });\n        if (enabledGuideID) {\n            this.showContent(enabledGuideID);\n        } else {\n            return warn(`No content enabled.`);\n        }\n    }\n\n    public getActiveGuide(): ActiveGuide | null {\n        if (!this.activeGuide) return null;\n        const { instance, id } = this.activeGuide;\n        const {\n            guideData,\n            getTrackingState,\n            getActiveSteps,\n            getProgress,\n            reRenderStepElements,\n        } = instance;\n\n        return {\n            id,\n            instance: {\n                guideData,\n                getTrackingState,\n                getProgress,\n                getActiveSteps,\n                reRenderStepElements,\n            }\n        };\n    }\n\n    private doesGuideExist(guideID: string): boolean {\n        return Object.keys(this.getContent()!)\n        .some(key => key === guideID);\n    }\n\n    public enable(guideID: string, toRefresh?: boolean): void {\n        let localData = this.getTrackingState();\n        if(!this.doesGuideExist(guideID)) {\n            return error(`Content with id '${guideID}' doesn't exist`);\n        }\n\n        // enable content with id $guideID, disable all else\n        Object.keys(localData).forEach(key => {\n            const { trackingState } = localData[key];\n            if(trackingState){\n                localData[key].trackingState.enabled = key === guideID;\n            }\n        });\n        saveState(localData);\n        if (toRefresh) {\n            this.refresh();\n        }\n    }\n\n    public disable(guideID: string, toRemove?: boolean): void {\n        let localData = loadState();\n        if(!this.doesGuideExist(guideID)) {\n            return error(`Content of id '${guideID}' doesn't exist`);\n        }\n        localData[guideID].trackingState.enabled = false;\n        saveState(localData);\n    }\n\n    public setContent(content: InputContent, defaults?: DeepPartial<ContentDefaults>): void {\n        /* console.log('passed to setContent:')\n        console.log(content); */\n        const mergedWithDefaultsContent = mergeContentWithDefaults(content, defaults);\n        /* console.log('merged with defaults:')\n        console.log(mergedWithDefaultsContent) */\n\n        // validate content\n        if (!isOfTypeContent(mergedWithDefaultsContent)) {\n            return error(\"Content data type is invalid\");\n        }\n        this.content = mergedWithDefaultsContent;\n\n        // for any already active guide\n        if (this.activeGuide) {\n            const contentIDExists = this.doesGuideExist(this.activeGuide.id);\n            // if the contentID doesn't exist at all in the new content received\n            if (!contentIDExists!) {\n                this.activeGuide.instance.removeAllActiveSteps!();\n                this.activeGuide = null;\n            }\n        }\n    }\n\n    public getContent(): Content {\n        return this.content;\n    }\n\n    public refresh(): void {\n        // run page elements through step display conditionals again\n        if (this.activeGuide) {\n            this.activeGuide!.instance.start!();\n            log(\"Lusift refreshed\");\n        } else {\n            warn(\"No active guide instance to refresh\");\n            // Assuming this method is called every time on page load.\n            // Better than running in constructor which runs on import of Lusift\n            this.showEnabledContent();\n        }\n    }\n\n    public showContent<T extends string>(contentID: T extends \"\" ? never : T): void {\n        // Forces specific Lusift content to appear for the current user by passing in the ID.\n\n        if (this.isDevMode){\n            return devNavMethod();\n        }\n        this.isDevMode = false;\n        const content = this.getContent();\n        if (Object.keys(content).length === 0) {\n            return error(`Content not set, pass valid content data to setContent()`);\n        }\n        // see if content exists for contentID\n        if (!this.doesGuideExist(contentID)) {\n            return error(`Content with id of ${contentID} doesn't exist`);\n        }\n        // when there's an active guide already\n        if (this.activeGuide) {\n            const { instance, id } = this.activeGuide;\n\n            if (id === contentID) {\n                this.activeGuide.instance.reRenderStepElements();\n                return error(`${contentID} is already active`);\n            } else {\n                return this.close();\n            }\n        }\n\n        // See if contentID, if in trackingState, isn't closed\n        // if it is, don't instantiate it\n        const guideTrackingState = loadState()[contentID]?.trackingState;\n        if(guideTrackingState?.finished || guideTrackingState?.prematurelyClosed) {\n            return warn(`Guide '${contentID}' is closed.`);\n        }\n        const newGuideInstance = new Guide(contentID);\n        this.enable(contentID);\n\n        const {\n            nextStep,\n            prevStep,\n            setStep,\n            remove,\n            getTrackingState,\n            reRenderStepElements,\n            start,\n            getActiveSteps,\n            getProgress,\n            removeAllActiveSteps,\n            guideData\n        } = newGuideInstance;\n\n        this.activeGuide = {\n            id: contentID,\n            instance: {\n                guideData,\n                getTrackingState: getTrackingState.bind(newGuideInstance),\n                getProgress: getProgress.bind(newGuideInstance),\n                getActiveSteps: getActiveSteps.bind(newGuideInstance),\n                reRenderStepElements: reRenderStepElements.bind(newGuideInstance),\n                removeAllActiveSteps: removeAllActiveSteps.bind(newGuideInstance),\n                start: start.bind(newGuideInstance)\n            }\n        };\n        newGuideInstance.start();\n\n        // attach active content's navigation methods, and hooks to Lusift instance\n        const activeGuideID = this.activeGuide!.id;\n\n        const close = () => {\n            if (this.activeGuide) {\n                remove.bind(newGuideInstance)();\n                this.disable(activeGuideID);\n                typeof this.onClose === \"function\" && this.onClose();\n                this.activeGuide = null;\n                log(`Closed ${activeGuideID}`);\n            } else {\n                return error(`No active guide to close`);\n            }\n        }\n\n        this.navigationMethods = {\n            next: nextStep.bind(newGuideInstance),\n            prev: prevStep.bind(newGuideInstance),\n            goto: setStep.bind(newGuideInstance),\n            close,\n        }\n    }\n    public onNext(): void {\n        const activeGuideID = this.activeGuide!.id;\n        if (activeGuideID){\n            return this.content[activeGuideID].data.onNext!();\n        }\n    }\n\n    public onPrev(): void {\n        const activeGuideID = this.activeGuide!.id;\n        if (activeGuideID){\n            return this.content[activeGuideID].data.onPrev!();\n        }\n    }\n\n    public onClose(): void {\n        const activeGuideID = this.activeGuide!.id;\n        if (activeGuideID){\n            return this.content[activeGuideID].data.onClose!();\n        }\n    }\n\n    public setGlobalStyle(styleText: string): void {\n        let customStyle = document.querySelector(\"style[lusift-custom-css]\");\n        customStyle.textContent = styleText;\n    }\n\n    public getTrackingState(): LocalState {\n        return loadState();\n    }\n\n    public devShowStep(guideID: string, stepNumber: number): void {\n        // dev mode: to be used to develop/style step elements\n        // if there is some other content active already, refuse to show dev mode\n        if (this.activeGuide) {\n            return warn(\n                `Can\\'t enable dev mode because a ` + `guide is active using showContent()`,\n            );\n        }\n        if (!this.content) {\n            return warn(\n                `Content not set, pass valid content object ` +\n                    `to setContent() before running devShowStep()`,\n            );\n        }\n        this.navigationMethods = {\n            next: devNavMethod,\n            prev: devNavMethod,\n            goto: devNavMethod,\n            close: devNavMethod,\n        };\n        this.isDevMode = true;\n\n        if (this.content[guideID]) {\n            const { steps } = this.content[guideID].data;\n            const { target, type } = steps[stepNumber];\n\n            if (!doesStepMatchDisplayCriteria({ target, type })) {\n                return warn(\n                    `Display criteria for step do not match. Navigate to ` +\n                        `the right target page and make sure that the target ` +\n                        `element is in the visible screen, then reload page.`,\n                );\n            }\n\n            if (steps[stepNumber]) {\n                startStepInstance(\n                    steps[stepNumber],\n                    guideID,\n                    () => {}\n                );\n                log(\n                    `%c Showing step ${stepNumber} of ${guideID} in dev mode`,\n                    \"background: #222; color: #bada55\",\n                );\n            } else {\n                error(`Guide '${guideID}' doesn't have a step ${stepNumber}`);\n            }\n        } else {\n            error(`Guide with id '${guideID}' doesn't exist`);\n        }\n    }\n}\n\nexport default Lusift;\n","import { window, document } from \"global\";\nimport lusiftDefaultCSS from \"./style/lusift.css\";\n\n// Inject default lusift global styles\nexport default () => {\n    if (typeof document === \"undefined\") return;\n\n    const lusiftDefault = document.createElement(\"style\");\n    lusiftDefault.type = \"text/css\";\n    lusiftDefault.setAttribute(\"lusift-default\", \"\");\n    lusiftDefault.textContent = lusiftDefaultCSS;\n\n    const lusiftCustom = document.createElement(\"style\");\n    lusiftCustom.type = \"text/css\";\n    lusiftCustom.setAttribute(\"lusift-custom\", \"\");\n\n    const customStyle = document.createElement(\"style\");\n    customStyle.type = \"text/css\";\n    customStyle.setAttribute(\"lusift-custom-css\", \"\");\n\n    const docFrag = document.createDocumentFragment();\n    // append all style elements to the document fragment\n    docFrag.appendChild(lusiftDefault);\n    docFrag.appendChild(lusiftCustom);\n    docFrag.appendChild(customStyle);\n    // append the document fragment to the document\n    document.head.appendChild(docFrag);\n};\n","import Lusift from \"./Lusift\";\nimport { LusiftInstance } from './types';\n\nconst lusiftInstance = new Lusift();\n\nconst {\n    setContent,\n    showContent,\n    getContent,\n    refresh,\n    getActiveGuide,\n    enable,\n    disable,\n    setGlobalStyle,\n    getTrackingState,\n    devShowStep,\n    close,\n    next,\n    prev,\n    goto,\n    onClose,\n    onNext,\n    onPrev,\n    render\n} = lusiftInstance;\n\n\nconst instance: LusiftInstance = {\n    setContent: setContent.bind(lusiftInstance),\n    showContent: showContent.bind(lusiftInstance),\n    getContent: getContent.bind(lusiftInstance),\n    refresh: refresh.bind(lusiftInstance),\n    getActiveGuide: getActiveGuide.bind(lusiftInstance),\n    enable: enable.bind(lusiftInstance),\n    disable: disable.bind(lusiftInstance),\n    setGlobalStyle: setGlobalStyle.bind(lusiftInstance),\n    getTrackingState: getTrackingState.bind(lusiftInstance),\n    devShowStep: devShowStep.bind(lusiftInstance),\n    close: close.bind(lusiftInstance),\n    next: next.bind(lusiftInstance),\n    prev: prev.bind(lusiftInstance),\n    goto: goto.bind(lusiftInstance),\n    onClose: onClose.bind(lusiftInstance),\n    onNext: onNext.bind(lusiftInstance),\n    onPrev: onPrev.bind(lusiftInstance),\n    render: render\n}\n\nexport default instance;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport Lusift from \"../../lusift\";\nimport { window, document } from \"global\";\nimport { Content } from \"../../common/types\";\nimport { vanillaRender } from \"../../common/utils\";\nimport { isReactComponent, isReactClassComponent } from \"../../common/utils/isOfType\";\n\nconst reactRender = (BodyComponent: any, targetPath: string, callback?: Function) => {\n    let isReact18 = false;\n\n    window.__REACT_DEVTOOLS_GLOBAL_HOOK__.renderers.forEach(r => {\n        isReact18 = r.version.startsWith('18');\n    });\n    const target = document.querySelector(targetPath);\n    ReactDOM.render(<BodyComponent />, target);\n    if (callback) callback();\n};\n\nconst renderBodyContent = (body: any, targetPath: string, callback?: Function): void => {\n    if (isReactComponent(body)) {\n        reactRender(body, targetPath, callback);\n    } else {\n        vanillaRender(body, targetPath, callback);\n    }\n};\n\nif (typeof window !== \"undefined\") {\n    window.addEventListener(\"error\", e => console.log(e), true);\n    Lusift.render = renderBodyContent;\n    window[\"Lusift\"] = Lusift;\n}\n\nexport { Lusift as default, Content as LusiftContent };\n","const vanillaRender = (elementToRender: string | Element, targetPath: string, callback?: Function) => {\n    const target = document.querySelector(targetPath)!;\n    if (elementToRender instanceof Element) {\n        target.appendChild(elementToRender);\n    } else {\n        target.innerHTML = elementToRender;\n    }\n    if (callback) callback();\n};\n\nexport default vanillaRender;\n"],"names":["window_1","window","global","self","log","console","warn","message","_i","args","messagePrefix","error","STATE_ITEM_NAME","loadState","serialisedState","localStorage","getItem","JSON","parse","err","saveState","state","stringify","setItem","isObject","item","Object","constructor","isObjectOrUndefined","object","isOfTypeTooltipData","arrow","offset","length","actions","placement","positions","forEach","p","push","includes","position","orientation","isOfTypeProgressConfig","progressBar","arrowSizeScale","contentBody","progressOn","backdrop","styleProps","isOfTypeStep","index","type","elementSelectorExists","elementSelector","path","comparator","value","isOfTypeTarget","target","data","isOfTypeTooltip","isOfTypeHotspot","closeButton","isOfTypeModal","isOfTypeContent","itemTypes","values","every","id","name","description","steps","hasOwnProperty","isOfTypeGuide","mergeDeep","source","output","assign","keys","key","styleObjectToString","stylesString","replace","m","toLowerCase","getStepUID","_a","guideID","getElementPosition","element","documentElement","document","body","scrollTop","pageYOffset","scrollLeft","pageXOffset","elementRect","getBoundingClientRect","top","left","right","width","bottom","height","changeAsyncStepStatus","stepIndex","toOpen","exisitingState","activeGuideID","Lusift","getActiveGuide","trackingState","asyncSteps","doesStepMatchesDisplayCriteria","criteriaMatch","targetPath","location","currentPath","endsWith","startsWith","slice","currentPathElements","split","valuePathElements","doesPathMatch","doesStepPathMatch","Boolean","querySelector","candidateSelectors","candidateSelector","join","NoElement","Element","matches","prototype","msMatchesSelector","webkitMatchesSelector","getRootNode","ownerDocument","getCandidatesIteratively","elements","includeContainer","options","candidates","elementsToCheck","Array","from","shift","tagName","assigned","assignedElements","nestedCandidates","children","flatten","apply","scope","call","filter","shadowRoot","getShadowRoot","validShadowRoot","shadowRootFilter","_nestedCandidates","unshift","getTabindex","node","isScope","tabIndex","test","isContentEditable","isNaN","parseInt","getAttribute","sortOrderedTabbables","a","b","documentOrder","isInput","isNonTabbableRadio","isRadio","radioSet","radioScope","form","queryRadios","querySelectorAll","CSS","escape","checked","nodes","i","getCheckedRadio","isTabbableRadio","isZeroArea","_node$getBoundingClie","isNodeMatchingSelectorFocusable","disabled","isHiddenInput","_ref","displayCheck","getComputedStyle","visibility","nodeUnderDetails","parentElement","nodeRootHost","host","nodeIsAttached","contains","originalNode","rootNode","assignedSlot","getClientRects","isHidden","some","child","isDetailsWithSummary","parentNode","isDisabledFromFieldset","isNodeMatchingSelectorTabbable","isValidShadowRootTabbable","shadowHostNode","sortByOrder","regularTabbables","orderedTabbables","candidateTabindex","content","sort","reduce","acc","sortable","concat","tabbable","el","bind","getCandidates","focusableCandidateSelector","isFocusable","Error","ownKeys","enumerableOnly","getOwnPropertySymbols","symbols","sym","getOwnPropertyDescriptor","enumerable","_defineProperty","obj","defineProperty","configurable","writable","trapQueue","activeFocusTraps","activateTrap","trap","activeTrap","pause","trapIndex","indexOf","splice","deactivateTrap","unpause","delay","fn","setTimeout","findIndex","arr","idx","valueOrHandler","_len","arguments","params","_key","getActualTarget","event","composedPath","createFocusTrap","userOptions","doc","config","getOwnPropertyDescriptors","defineProperties","_objectSpread2","returnFocusOnDeactivate","escapeDeactivates","delayInitialFocus","containers","tabbableGroups","nodeFocusedBeforeActivation","mostRecentlyFocusedNode","active","paused","delayInitialFocusTimer","undefined","getOption","configOverrideOptions","optionName","configOptionName","containersContain","container","getNodeForOption","optionValue","_len2","_key2","getInitialFocusNode","activeElement","firstTabbableGroup","firstTabbableNode","updateTabbableNodes","map","tabbableNodes","lastTabbableNode","group","tryFocus","focus","preventScroll","select","isSelectableInput","getReturnFocusNode","previousActiveElement","checkPointerDown","e","clickOutsideDeactivates","deactivate","returnFocus","allowOutsideClick","preventDefault","checkFocusIn","targetContained","Document","stopImmediatePropagation","checkKey","keyCode","isEscapeEvent","isTabEvent","destinationNode","containerIndex","shiftKey","startOfGroupIndex","_ref2","destinationGroupIndex","lastOfGroupIndex","_ref3","_destinationGroupIndex","checkTab","checkClick","addListeners","addEventListener","capture","passive","removeListeners","removeEventListener","activate","activateOptions","this","onActivate","onPostActivate","checkCanFocusTrap","finishActivation","then","deactivateOptions","clearTimeout","onDeactivate","onPostDeactivate","checkCanReturnFocus","finishDeactivation","updateContainerElements","containerElements","elementsAsArray","addFocusTrap","arg","_b","ft","focusTrap.createFocusTrap","hasFocussableElements","root","focusableEls","isDisabledOrHidden","isTabbableAndVisible","isProgrammaticallyHidden","style","display","debounce","ms","timeout","MODAL_OVERLAY_CLASS","MODAL_CLASS","DEFAULT_TOOLTIP_BORDER_RADIUS","DEFAULT_MODAL_BORDER_RADIUS","renderProgressBar","currentGuide","currentStep","getContent","currentStepIndex","progressBarData","borderRadius","progress","instance","getProgress","progressBarElement","createElement","classList","add","setAttribute","renderCloseXButton","stepType","t","n","o","r","s","box","l","d","_instance","props","updateDebounce","onHide","transitionDuration","setState","isShown","onShow","c","u","passedPlacement","tooltipElement","toResetPosition","fui","h","passedOffset","resetPlacementOnUpdate","newlyShown","toShift","toShowArrow","arrowElement","__awaiter","f","w","g","__generator","label","__assign","middleware","__spreadArray","mainAxis","crossAxis","autoPlacement","padding","size","reference","floating","hide","computePosition","sent","v","x","_","y","E","S","hideOnReferenceHidden","hideOnTooltipEscape","scrollIntoView","showOnCreate","getState","toHide","middlewareData","referenceHidden","escaped","behavior","block","inline","centerOffset","O","T","C","k","H","A","allowHTML","factorArrowInOffset","hideOnClick","onClickOutside","onStateChange","onRemove","onBeforeFirstRender","onAfterFirstRender","maxWidth","zIndex","updateOnEvents","isRemoved","updateListenerCleanup","toHideTooltip","clickHandler","tp","textContent","head","appendChild","hookEventListeners","debouncedUpdate","update","autoUpdate","updateTransitionDuration","create","className","innerHTML","innerText","show","remove","DEFAULT_ARROW_SIZE","default","Math","sqrt","exports","require$$0","require$$1","createTooltip","floatingTooltip","div","button","renderFooter","navSection","nextButton","prevButton","dismissLink","dismiss","text","prev","next","prevNextBtns","renderTooltip","uid","backgroundColor","prepend","bodyContent","footerContent","activeGuide","render","hexToRgbA","hex","opacity","substring","createOverlay","targetElement","stageGap","color","overlay","targetPosition","TOOLTIP_Z_INDEX","pointerEvents","boxShadow","removeOverlay","detachOverlay","removeChild","attachOverlay","getElement","targetSelector","stagedTargetClass","copyObject","focusTrap","Backdrop","toStopOverlay","createOverlayElement","Tooltip","fuitInstance","removeAllEventListeners","backdropInstance","isTooltipShown","nextOnOverlayClick","getElementsByClassName","overlaySelectorClass","_this","addEventListenerToTarget","eventType","_c","addBackdrop","_d","debouncedBackdropReset_1","_x","resetBackdrop","backdropAutoUpdateCleanup","ancestorScroll","ancestorResize","elementResize","method","getListenerFromMethod","targetsAndEventListeners","createModal","modalOverlay","modal","lusiftWrapper","overflowY","background","margin","removeModal","escToClose","clickOutsideToClose","isDevMode","closest","Modal","tooltipInstance","tip","createBeaconElement","beaconData","beaconID","toggleTooltip","beaconContainer","beaconElement","beaconEventReceiver","tipID","addBeacon","createTip","Hotspot","targetTop","targetLeft","targetWidth","targetHeight","beacon","beaconPlacement","positionBeacon","getElementById","updateBeaconPosition","removeMethod","close","removeAndCloseAsync","createHotspotTooltip","debouncedUpdateBeaconPosition","beaconAutoUpdateCleanup","activeHotspot","hideTooltip","async","removeResizeObservers","startStepInstance","stepData","activeStepInstance","styleProps_1","localGuideState","guideData","resetTrackingState","Guide","activeSteps","newTrackingState","finished","prematurelyClosed","enabled","step","getTrackingState","removeIllegalSteps","attemptToStartAsyncSteps","attemptToShowActiveStep","stepInstance","removeAllActiveSteps","start","isAsyncStep","displayCriteriaMatches","doesStepMatchDisplayCriteria","isStepActive","setTrackingState","syncSteps","existingState","generateNewTrackingState","newStepNum","closeCurrentStep","find","newStep","closeOnLastNext","setStep","onNext","onPrev","defaultGuideData","onClose","removeUndefinedFieldsFromContent","defaults","tooltip","hotspot","combineContentWithDefaults","contentDefaults","completedGuideData","completedStep","noOp","devNavMethod","goto","lusiftDefault","lusiftCustom","customStyle","docFrag","createDocumentFragment","addDefaultCSS","navigationMethods","localData","enabledGuideID","showContent","getActiveSteps","reRenderStepElements","toRefresh","doesGuideExist","refresh","toRemove","mergedWithDefaultsContent","mergeContentWithDefaults","showEnabledContent","contentID","guideTrackingState","newGuideInstance","enable","nextStep","prevStep","disable","styleText","stepNumber","lusiftInstance","setContent","setGlobalStyle","devShowStep","callback","BodyComponent","__REACT_DEVTOOLS_GLOBAL_HOOK__","renderers","version","ReactDOM","React","reactRender","elementToRender","vanillaRender"],"mappings":"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"}